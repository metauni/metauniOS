<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXE3BE5F5EE4134149859FD53BB4AEA501">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">MainModule</string>
			<string name="ScriptGuid">{8F9AB8DC-2E4D-40EA-B4AC-A78633D4A5BB}</string>
			<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Wraps the Nexus VR Character Model main module for loading.
When required with an id, the main module's source isn't
included, which makes the client see an empty script.
--]]

return require(script:WaitForChild("NexusVRCharacterModel"))]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXBE649757847148C5927D142E9B18F5A5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">NexusVRCharacterModel</string>
				<string name="ScriptGuid">{50975A0B-D53B-4316-8FF8-F67765BA7423}</string>
				<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Loads Nexus VR Character Model.
--]]
--!strict

--Client should send replication at 30hz.
--A buffer is added in case this rate is exceeded
--briefly, such as an unstable connection.
local REPLICATION_RATE_LIMIT = 35



local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local StarterPlayer = game:GetService("StarterPlayer")

local Settings = require(script:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local RateLimiter = require(script:WaitForChild("State"):WaitForChild("RateLimiter"))

local NexusVRCharacterModel = {}



--[[
Sets the configuration to use. Intended to be
run once by the server.
--]]
function NexusVRCharacterModel:SetConfiguration(Configuration: any): ()
    --Create the value.
    local ConfigurationValue = script:FindFirstChild("Configuration")
    if not ConfigurationValue then
        ConfigurationValue = Instance.new("StringValue")
        ConfigurationValue.Name = "Configuration"
        ConfigurationValue.Parent = script
    end

    --Store the configuration.
    ConfigurationValue.Value = HttpService:JSONEncode(Configuration)
    Settings:SetDefaults(Configuration)
end

--[[
Loads Nexus VR Character Model.
--]]
function NexusVRCharacterModel:Load(): ()
    --Return if a version is already loaded.
    if ReplicatedStorage:FindFirstChild("NexusVRCharacterModel") then
        return
    end

    --Rename and move the script to ReplicatedStorage.
    script.Name = "NexusVRCharacterModel"
    script:WaitForChild("NexusVRCore").Parent = ReplicatedStorage
    script.Parent = ReplicatedStorage;

    --Output any warnings.
    (require(ReplicatedStorage:WaitForChild("NexusVRCharacterModel"):WaitForChild("Util"):WaitForChild("Warnings")) :: any)()

    --Set up the client scripts.
    local NexusVRCharacterModelClientLoader = script:WaitForChild("NexusVRCharacterModelClientLoader")
    for _,Player in pairs(Players:GetPlayers()) do
        task.spawn(function()
            --Create and store a ScreenGui with the script.
            --This prevents the script disappearing on respawn.
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.ResetOnSpawn = false
            ScreenGui.Name = "NexusVRCharacterModelClientLoader"
            NexusVRCharacterModelClientLoader:Clone().Parent = ScreenGui
            ScreenGui.Parent = Player:WaitForChild("PlayerGui")
        end)
    end
    NexusVRCharacterModelClientLoader:Clone().Parent = StarterPlayer:WaitForChild("StarterPlayerScripts")

    --Set up replication.
    local ReadyPlayers = {}
    local UpdateRateLimiter = RateLimiter.new(REPLICATION_RATE_LIMIT)

    local UpdateInputsEvent = Instance.new("RemoteEvent")
    UpdateInputsEvent.Name = "UpdateInputs"
    UpdateInputsEvent.Parent = script

    local ReplicationReadyEvent = Instance.new("RemoteEvent")
    ReplicationReadyEvent.Name = "ReplicationReady"
    ReplicationReadyEvent.Parent = script

    UpdateInputsEvent.OnServerEvent:Connect(function(Player,HeadCFrame,LeftHandCFrame,RightHandCFrame)
        --Ignore the input if 3 CFrames aren't given.
        if typeof(HeadCFrame) ~= "CFrame" then return end
        if typeof(LeftHandCFrame) ~= "CFrame" then return end
        if typeof(RightHandCFrame) ~= "CFrame" then return end

        --Ignore if the rate limit was reached.
        if UpdateRateLimiter:RateLimitReached(Player) then return end

        --Replicate the CFrames to the other players.
        for _,OtherPlayer in Players:GetPlayers() do
            if Player ~= OtherPlayer and ReadyPlayers[OtherPlayer] then
                UpdateInputsEvent:FireClient(OtherPlayer,Player,HeadCFrame,LeftHandCFrame,RightHandCFrame)
            end
        end
    end)

    ReplicationReadyEvent.OnServerEvent:Connect(function(Player)
        ReadyPlayers[Player] = true
    end)

    Players.PlayerRemoving:Connect(function(Player)
        ReadyPlayers[Player] = nil
    end)

    --Load Nexus VR Backpack.
    if Settings:GetSetting("Extra.NexusVRBackpackEnabled") ~= false then
        (require(10728805649) :: any)()
    end
end




NexusVRCharacterModel.Api = (require(script:WaitForChild("Api")) :: any)()
return NexusVRCharacterModel]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXA0A2111150BB4049A291036275F74C5A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Api</string>
					<string name="ScriptGuid">{2AA1E230-AD46-406B-A9B0-DF1A90410747}</string>
					<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Main module for creating the usable API.
--]]
--!strict

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")



return function()
    local NexusVRCharacterModel = script.Parent
    local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))
    local API = {} :: any
    API.Registered = NexusEvent.new()

    --[[
    Stores an API that can be referenced. If the API is already stored,
    an error will be thrown.
    --]]
    function API:Register(ApiName: string, Api: any): ()
        if self[ApiName] ~= nil then
            error("API already registered: "..tostring(ApiName))
        end
        self[ApiName] = Api
        self.Registered:Fire(ApiName)
    end

    --[[
    Waits for an API to be registered and returns the API. If it was
    already registered, it returns the API without waiting. Similar
    to instances, this would be treated like WaitForChild where the
    usage is optional instead of indexing (ex: API:WaitFor("MyApi")
    vs API.MyApi) as long as the consequences of an API not
    being registered are accepted.
    --]]
    function API:WaitFor(ApiName: string): any
        while not self[ApiName] do
            self.Registered:Wait()
        end
        return self[ApiName]
    end

    --[[
    Invokes a callback when an API is registered with a given
    name. If it is already registered, the callback will run
    asynchronously. This is intended for setting up an API
    call without blocking for WaitFor.
    --]]
    function API:OnRegistered(ApiName: string, RegisteredCallback: (any) -> ()): ()
        --Run the callback immediately if the API is loaded.
        if self[ApiName] then
            task.spawn(function()
                RegisteredCallback(self[ApiName])
            end)
            return
        end

        --Connect the registered event.
        self.Registered:Connect(function(RegisteredFunctionName)
            if ApiName ~= RegisteredFunctionName then return end
            RegisteredCallback(self[ApiName])
        end)
    end

    --Create the client API.
    --Done in a task to resolve recurisve requiring.
    if RunService:IsClient() then
        task.defer(function()
            --Build the initial shims for the APIs.
            local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
            local ControlService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")).GetInstance()
            API:Register("Camera", setmetatable({}, {__index=CameraService}))
            API:Register("Controller", setmetatable({}, {__index=ControlService}))
            API:Register("Input", setmetatable({}, {__index=require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()}))
            API:Register("Settings", setmetatable({}, {__index=require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()}))

            --Add the additional API adapters for the shims.
            API.Camera.GetActiveCamera = function()
                return CameraService.ActiveCamera
            end
            API.Controller.GetActiveController = function()
                return ControlService.ActiveController
            end

            --Add the custom APIs for the shims.
            local ActiveControllers = {}
            API.Controller.SetControllerInputEnabled = function(_, Hand: Enum.UserCFrame, Enabled: boolean): ()
                if Hand ~= Enum.UserCFrame.LeftHand and Hand ~= Enum.UserCFrame.RightHand then
                    error("The following UserCFrame is invalid and can't be disabled: "..tostring(Hand))
                end
                ActiveControllers[Hand] = (Enabled ~= false)
            end
            API.Controller.EnableControllerInput = function(self, Hand: Enum.UserCFrame): ()
                self:SetControllerInputEnabled(Hand, true)
            end
            API.Controller.DisableControllerInput = function(self, Hand: Enum.UserCFrame): ()
                self:SetControllerInputEnabled(Hand, false)
            end
            API.Controller.IsControllerInputEnabled = function(_, Hand: Enum.UserCFrame): boolean
                if Hand ~= Enum.UserCFrame.LeftHand and Hand ~= Enum.UserCFrame.RightHand then
                    error("The following UserCFrame is invalid and can't be disabled: "..tostring(Hand))
                end
                return ActiveControllers[Hand] ~= false
            end

            --Create the Menu API.
            --The Menu API does not work outside of VR.
            --Release 454 and later has/had a bug that made VREnabled false on start. This mitigates that now and in the future if VR loads dynamically.
            local MenuAPI = {} :: any
            local function GetMainMenu(): any
                if not MenuAPI.Enabled then
                    error("Menu API is not enabled for non-VR players. Check Api.Menu.Enabled before calling.")
                end
                return require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("MainMenu")).GetInstance()
            end
            if UserInputService.VREnabled then
                MenuAPI.Enabled = true
            else
                MenuAPI.Enabled = false
                UserInputService:GetPropertyChangedSignal("VREnabled"):Connect(function()
                    MenuAPI.Enabled = UserInputService.VREnabled
                end)
            end

            MenuAPI.CreateView = function(_, ...)
                return GetMainMenu():CreateView(...)
            end
            MenuAPI.IsOpen = function()
                return GetMainMenu().Enabled
            end
            MenuAPI.Open = function(self)
                if self:IsOpen() then return end
                GetMainMenu():Toggle()
            end
            MenuAPI.Close = function(self)
                if not self:IsOpen() then return end
                GetMainMenu():Toggle()
            end
            API:Register("Menu", MenuAPI)
        end)
    end

    --Return the APIs.
    return API
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8D6332F75B2445BA931D2EB6EF94F7EA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Character</string>
					<string name="ScriptGuid">{05258766-42C2-46A9-B059-56EB07395680}</string>
					<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Manipulates a character model.
--]]
--!strict

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local NexusVRCharacterModel = script.Parent
local Head = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Head"))
local Torso = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Torso"))
local Appendage = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Appendage"))
local FootPlanter = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("FootPlanter"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local UpdateInputs = NexusVRCharacterModel:WaitForChild("UpdateInputs") :: RemoteEvent

local Character = {}
Character.__index = Character

export type Character = {
    new: (CharacterModel: Model) -> Character,

    UpdateFromInputs: (self: Character, HeadControllerCFrame: CFrame, LeftHandControllerCFrame: CFrame, RightHandControllerCFrame: CFrame) -> (),
}



--[[
Creates a character.
--]]
function Character.new(CharacterModel: Model): Character
    local self = {
        CharacterModel = CharacterModel,
        TweenComponents = true,
    }
    setmetatable(self, Character)

    --Determine if the arms can be disconnected.
    --Checking for the setting to be explicitly false is done in case the setting is undefined (default is true).
    local PreventArmDisconnection = false
    if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
        local Setting = Settings:GetSetting("Appearance.LocalAllowArmDisconnection")
        if Setting == false then
            PreventArmDisconnection = true
        end
    else
        local Setting = Settings:GetSetting("Appearance.NonLocalAllowArmDisconnection")
        if Setting == false then
            PreventArmDisconnection = true
        end
    end

    --Store the body parts.
    self.Humanoid = CharacterModel:WaitForChild("Humanoid")
    self.Parts = {
        Head = CharacterModel:WaitForChild("Head"),
        UpperTorso = CharacterModel:WaitForChild("UpperTorso"),
        LowerTorso = CharacterModel:WaitForChild("LowerTorso"),
        HumanoidRootPart = CharacterModel:WaitForChild("HumanoidRootPart"),
        RightUpperArm = CharacterModel:WaitForChild("RightUpperArm"),
        RightLowerArm = CharacterModel:WaitForChild("RightLowerArm"),
        RightHand = CharacterModel:WaitForChild("RightHand"),
        LeftUpperArm = CharacterModel:WaitForChild("LeftUpperArm"),
        LeftLowerArm = CharacterModel:WaitForChild("LeftLowerArm"),
        LeftHand = CharacterModel:WaitForChild("LeftHand"),
        RightUpperLeg = CharacterModel:WaitForChild("RightUpperLeg"),
        RightLowerLeg = CharacterModel:WaitForChild("RightLowerLeg"),
        RightFoot = CharacterModel:WaitForChild("RightFoot"),
        LeftUpperLeg = CharacterModel:WaitForChild("LeftUpperLeg"),
        LeftLowerLeg = CharacterModel:WaitForChild("LeftLowerLeg"),
        LeftFoot = CharacterModel:WaitForChild("LeftFoot"),
    }
    self.Motors = {
        Neck = self.Parts.Head:WaitForChild("Neck"),
        Waist = self.Parts.UpperTorso:WaitForChild("Waist"),
        Root = self.Parts.LowerTorso:WaitForChild("Root"),
        RightShoulder = self.Parts.RightUpperArm:WaitForChild("RightShoulder"),
        RightElbow = self.Parts.RightLowerArm:WaitForChild("RightElbow"),
        RightWrist = self.Parts.RightHand:WaitForChild("RightWrist"),
        LeftShoulder = self.Parts.LeftUpperArm:WaitForChild("LeftShoulder"),
        LeftElbow = self.Parts.LeftLowerArm:WaitForChild("LeftElbow"),
        LeftWrist = self.Parts.LeftHand:WaitForChild("LeftWrist"),
        RightHip = self.Parts.RightUpperLeg:WaitForChild("RightHip"),
        RightKnee = self.Parts.RightLowerLeg:WaitForChild("RightKnee"),
        RightAnkle = self.Parts.RightFoot:WaitForChild("RightAnkle"),
        LeftHip = self.Parts.LeftUpperLeg:WaitForChild("LeftHip"),
        LeftKnee = self.Parts.LeftLowerLeg:WaitForChild("LeftKnee"),
        LeftAnkle = self.Parts.LeftFoot:WaitForChild("LeftAnkle"),
    }
    self.Attachments = {
        Head = {
            NeckRigAttachment = self.Parts.Head:WaitForChild("NeckRigAttachment"),
        },
        UpperTorso = {
            NeckRigAttachment = self.Parts.UpperTorso:WaitForChild("NeckRigAttachment"),
            LeftShoulderRigAttachment = self.Parts.UpperTorso:WaitForChild("LeftShoulderRigAttachment"),
            RightShoulderRigAttachment = self.Parts.UpperTorso:WaitForChild("RightShoulderRigAttachment"),
            WaistRigAttachment = self.Parts.UpperTorso:WaitForChild("WaistRigAttachment"),
        },
        LowerTorso = {
            WaistRigAttachment = self.Parts.LowerTorso:WaitForChild("WaistRigAttachment"),
            LeftHipRigAttachment = self.Parts.LowerTorso:WaitForChild("LeftHipRigAttachment"),
            RightHipRigAttachment = self.Parts.LowerTorso:WaitForChild("RightHipRigAttachment"),
            RootRigAttachment = self.Parts.LowerTorso:WaitForChild("RootRigAttachment"),
        },
        HumanoidRootPart = {
            RootRigAttachment = self.Parts.HumanoidRootPart:WaitForChild("RootRigAttachment"),
        },
        RightUpperArm = {
            RightShoulderRigAttachment = self.Parts.RightUpperArm:WaitForChild("RightShoulderRigAttachment"),
            RightElbowRigAttachment = self.Parts.RightUpperArm:WaitForChild("RightElbowRigAttachment"),
        },
        RightLowerArm = {
            RightElbowRigAttachment = self.Parts.RightLowerArm:WaitForChild("RightElbowRigAttachment"),
            RightWristRigAttachment = self.Parts.RightLowerArm:WaitForChild("RightWristRigAttachment"),
        },
        RightHand = {
            RightWristRigAttachment = self.Parts.RightHand:WaitForChild("RightWristRigAttachment"),
        },
        LeftUpperArm = {
            LeftShoulderRigAttachment = self.Parts.LeftUpperArm:WaitForChild("LeftShoulderRigAttachment"),
            LeftElbowRigAttachment = self.Parts.LeftUpperArm:WaitForChild("LeftElbowRigAttachment"),
        },
        LeftLowerArm = {
            LeftElbowRigAttachment = self.Parts.LeftLowerArm:WaitForChild("LeftElbowRigAttachment"),
            LeftWristRigAttachment = self.Parts.LeftLowerArm:WaitForChild("LeftWristRigAttachment"),
        },
        LeftHand = {
            LeftWristRigAttachment = self.Parts.LeftHand:WaitForChild("LeftWristRigAttachment"),
        },
        RightUpperLeg = {
            RightHipRigAttachment = self.Parts.RightUpperLeg:WaitForChild("RightHipRigAttachment"),
            RightKneeRigAttachment = self.Parts.RightUpperLeg:WaitForChild("RightKneeRigAttachment"),
        },
        RightLowerLeg = {
            RightKneeRigAttachment = self.Parts.RightLowerLeg:WaitForChild("RightKneeRigAttachment"),
            RightAnkleRigAttachment = self.Parts.RightLowerLeg:WaitForChild("RightAnkleRigAttachment"),
        },
        RightFoot = {
            RightAnkleRigAttachment = self.Parts.RightFoot:WaitForChild("RightAnkleRigAttachment"),
            RightFootAttachment = self.Parts.RightFoot:FindFirstChild("RightFootAttachment"),
        },
        LeftUpperLeg = {
            LeftHipRigAttachment = self.Parts.LeftUpperLeg:WaitForChild("LeftHipRigAttachment"),
            LeftKneeRigAttachment = self.Parts.LeftUpperLeg:WaitForChild("LeftKneeRigAttachment"),
        },
        LeftLowerLeg = {
            LeftKneeRigAttachment = self.Parts.LeftLowerLeg:WaitForChild("LeftKneeRigAttachment"),
            LeftAnkleRigAttachment = self.Parts.LeftLowerLeg:WaitForChild("LeftAnkleRigAttachment"),
        },
        LeftFoot = {
            LeftAnkleRigAttachment = self.Parts.LeftFoot:WaitForChild("LeftAnkleRigAttachment"),
            LeftFootAttachment = self.Parts.LeftFoot:FindFirstChild("LeftFootAttachment"),
        },
    }
    self.ScaleValues = {
        BodyDepthScale = self.Humanoid:WaitForChild("BodyDepthScale"),
        BodyWidthScale = self.Humanoid:WaitForChild("BodyWidthScale"),
        BodyHeightScale = self.Humanoid:WaitForChild("BodyHeightScale"),
        HeadScale = self.Humanoid:WaitForChild("HeadScale"),
    }

    --Add the missing attachments that not all rigs have.
    if not self.Attachments.RightFoot.RightFootAttachment then
        local NewAttachment = Instance.new("Attachment")
        NewAttachment.Position = Vector3.new(0, -(self.Parts.RightFoot :: BasePart).Size.Y / 2, 0)
        NewAttachment.Name = "RightFootAttachment"

        local OriginalPositionValue = Instance.new("Vector3Value")
        OriginalPositionValue.Name = "OriginalPosition"
        OriginalPositionValue.Value = NewAttachment.Position
        OriginalPositionValue.Parent = NewAttachment
        NewAttachment.Parent = self.Parts.RightFoot
        self.Attachments.RightFoot.RightFootAttachment = NewAttachment
    end
    if not self.Attachments.LeftFoot.LeftFootAttachment then
        local NewAttachment = Instance.new("Attachment")
        NewAttachment.Position = Vector3.new(0, -(self.Parts.LeftFoot :: BasePart).Size.Y / 2, 0)
        NewAttachment.Name = "LeftFootAttachment"

        local OriginalPositionValue = Instance.new("Vector3Value")
        OriginalPositionValue.Name = "OriginalPosition"
        OriginalPositionValue.Value = NewAttachment.Position
        OriginalPositionValue.Parent = NewAttachment
        NewAttachment.Parent = self.Parts.LeftFoot
        self.Attachments.LeftFoot.LeftFootAttachment = NewAttachment
    end

    --Store the limbs.
    self.Head = Head.new(self.Parts.Head :: BasePart)
    self.Torso = Torso.new(self.Parts.LowerTorso :: BasePart, self.Parts.UpperTorso :: BasePart)
    self.LeftArm = Appendage.new(CharacterModel:WaitForChild("LeftUpperArm") :: BasePart, CharacterModel:WaitForChild("LeftLowerArm") :: BasePart, CharacterModel:WaitForChild("LeftHand") :: BasePart, "LeftShoulderRigAttachment", "LeftElbowRigAttachment", "LeftWristRigAttachment", "LeftGripAttachment", PreventArmDisconnection)
    self.RightArm = Appendage.new(CharacterModel:WaitForChild("RightUpperArm") :: BasePart, CharacterModel:WaitForChild("RightLowerArm") :: BasePart, CharacterModel:WaitForChild("RightHand") :: BasePart, "RightShoulderRigAttachment", "RightElbowRigAttachment", "RightWristRigAttachment", "RightGripAttachment", PreventArmDisconnection)
    self.LeftLeg = Appendage.new(CharacterModel:WaitForChild("LeftUpperLeg") :: BasePart, CharacterModel:WaitForChild("LeftLowerLeg") :: BasePart, CharacterModel:WaitForChild("LeftFoot") :: BasePart, "LeftHipRigAttachment", "LeftKneeRigAttachment", "LeftAnkleRigAttachment", "LeftFootAttachment", true)
    self.LeftLeg.InvertBendDirection = true
    self.RightLeg = Appendage.new(CharacterModel:WaitForChild("RightUpperLeg") :: BasePart, CharacterModel:WaitForChild("RightLowerLeg") :: BasePart, CharacterModel:WaitForChild("RightFoot") :: BasePart, "RightHipRigAttachment", "RightKneeRigAttachment", "RightAnkleRigAttachment", "RightFootAttachment", true)
    self.RightLeg.InvertBendDirection = true
    self.FootPlanter = FootPlanter:CreateSolver(CharacterModel:WaitForChild("LowerTorso"), self.ScaleValues.BodyHeightScale)

    --Stop the character animations.
    local Animator = self.Humanoid:FindFirstChild("Animator") :: Animator
    if Animator then
        if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
            CharacterModel:WaitForChild("Animate"):Destroy()
            for _, Track in Animator:GetPlayingAnimationTracks() do
                Track:AdjustWeight(0, 0)
                Track:Stop(0)
            end
            Animator.AnimationPlayed:Connect(function(Track)
                Track:AdjustWeight(0, 0)
                Track:Stop(0)
            end)
        else
            Animator:Destroy()
        end
    end
    self.Humanoid.ChildAdded:Connect(function(NewAnimator)
        if NewAnimator:IsA("Animator") then
            if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
                CharacterModel:WaitForChild("Animate"):Destroy()
                for _, Track in NewAnimator:GetPlayingAnimationTracks() do
                    Track:AdjustWeight(0, 0)
                    Track:Stop(0)
                end
                NewAnimator.AnimationPlayed:Connect(function(Track)
                    Track:AdjustWeight(0, 0)
                    Track:Stop(0)
                end)
            else
                NewAnimator:Destroy()
            end
        end
    end)

    --Set up replication at 30hz.
    if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
        task.spawn(function()
            while (self.Humanoid :: Humanoid).Health > 0 do
                --Send the new CFrames if the CFrames changed.
                if (self :: any).LastReplicationCFrames ~= (self :: any).ReplicationCFrames then
                    (self :: any).LastReplicationCFrames = (self :: any).ReplicationCFrames
                    UpdateInputs:FireServer(unpack((self :: any).ReplicationCFrames))
                end

                --Wait 1/30th of a second to send the next set of CFrames.
                task.wait(1 / 30)
            end
        end)
    end
    
    return (self :: any) :: Character
end

--[[
Returns the SeatPart of the humanoid.
SeatPart is not replicated to new players, which results in
strange movements of character.
https://devforum.roblox.com/t/seat-occupant-and-humanoid-seatpart-not-replicating-to-new-players-to-a-server/261545
--]]
function Character:GetHumanoidSeatPart(): BasePart?
    --Return nil if the Humanoid is not sitting.
    if not self.Humanoid.Sit then
        return nil
    end

    --Return if the seat part is defined.
    if self.Humanoid.SeatPart then
        return self.Humanoid.SeatPart
    end

    --Iterated through the connected parts and return if a seat exists.
    --While SeatPart may not be set, a SeatWeld does exist.
    for _, ConnectedPart in self.Parts.HumanoidRootPart:GetConnectedParts() do
        if ConnectedPart:IsA("Seat") or ConnectedPart:IsA("VehicleSeat") then
            return ConnectedPart
        end
    end
    return nil
end
--[[
Sets a property. The property will either be
set instantly or tweened depending on how
it is configured.
--]]
function Character:SetCFrameProperty(Object: Instance, PropertyName: string, PropertyValue: any): ()
    if self.TweenComponents then
        TweenService:Create(
            Object,
            TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {
                [PropertyName] = PropertyValue,
            }
        ):Play()
    else
        (Object :: any)[PropertyName] = PropertyValue
    end
end

--[[
Sets the transform of a motor.
--]]
function Character:SetTransform(MotorName: string, AttachmentName: string, StartLimbName: string, EndLimbName: string, StartCFrame: CFrame, EndCFrame: CFrame): ()
    self:SetCFrameProperty(self.Motors[MotorName], "Transform", (StartCFrame * self.Attachments[StartLimbName][AttachmentName].CFrame):Inverse() * (EndCFrame * self.Attachments[EndLimbName][AttachmentName].CFrame))
end

--[[
Updates the character from the inputs.
--]]
function Character:UpdateFromInputs(HeadControllerCFrame: CFrame, LeftHandControllerCFrame: CFrame, RightHandControllerCFrame: CFrame): ()
    --Return if the humanoid is dead.
    if self.Humanoid.Health <= 0 then
        return
    end

    --Call the other method if there is a SeatPart.
    --The math below is not used while in seats due to assumptions made while standing.
    --The CFrames will already be in local space from the replication.
    local SeatPart = self:GetHumanoidSeatPart()
    if SeatPart then
        self:UpdateFromInputsSeated(HeadControllerCFrame, LeftHandControllerCFrame, RightHandControllerCFrame)
        return
    end

    --Get the CFrames.
    local HeadCFrame = self.Head:GetHeadCFrame(HeadControllerCFrame)
    local NeckCFrame = self.Head:GetNeckCFrame(HeadControllerCFrame)
	local LowerTorsoCFrame: CFrame, UpperTorsoCFrame = self.Torso:GetTorsoCFrames(NeckCFrame)
	local JointCFrames = self.Torso:GetAppendageJointCFrames(LowerTorsoCFrame, UpperTorsoCFrame)
	local LeftUpperArmCFrame, LeftLowerArmCFrame, LeftHandCFrame = self.LeftArm:GetAppendageCFrames(JointCFrames["LeftShoulder"], LeftHandControllerCFrame)
	local RightUpperArmCFrame, RightLowerArmCFrame, RightHandCFrame = self.RightArm:GetAppendageCFrames(JointCFrames["RightShoulder"], RightHandControllerCFrame)

    --Set the character CFrames.
    --HumanoidRootParts must always face up. This makes the math more complicated.
    --Setting the CFrame directly to something not facing directly up will result in the physics
    --attempting to correct that within the next frame, causing the character to appear to move.
    local LeftFoot: CFrame, RightFoot: CFrame = self.FootPlanter:GetFeetCFrames()
    local LeftUpperLegCFrame, LeftLowerLegCFrame, LeftFootCFrame = self.LeftLeg:GetAppendageCFrames(JointCFrames["LeftHip"], LeftFoot * CFrame.Angles(0, math.pi, 0))
    local RightUpperLegCFrame, RightLowerLegCFrame, RightFootCFrame = self.RightLeg:GetAppendageCFrames(JointCFrames["RightHip"], RightFoot * CFrame.Angles(0, math.pi, 0))
    local TargetHumanoidRootPartCFrame = LowerTorsoCFrame * self.Attachments.LowerTorso.RootRigAttachment.CFrame * self.Attachments.HumanoidRootPart.RootRigAttachment.CFrame:Inverse()
    local ActualHumanoidRootPartCFrame: CFrame = self.Parts.HumanoidRootPart.CFrame
    local HumanoidRootPartHeightDifference = ActualHumanoidRootPartCFrame.Y - TargetHumanoidRootPartCFrame.Y
    local NewTargetHumanoidRootPartCFrame = CFrame.new(TargetHumanoidRootPartCFrame.Position)
    self:SetCFrameProperty(self.Parts.HumanoidRootPart, "CFrame", CFrame.new(0, HumanoidRootPartHeightDifference, 0) * NewTargetHumanoidRootPartCFrame)
    self:SetCFrameProperty(self.Motors.Root, "Transform", CFrame.new(0, -HumanoidRootPartHeightDifference, 0) * (NewTargetHumanoidRootPartCFrame * self.Attachments.HumanoidRootPart.RootRigAttachment.CFrame):Inverse() * LowerTorsoCFrame * self.Attachments.LowerTorso.RootRigAttachment.CFrame)
    self:SetTransform("RightHip", "RightHipRigAttachment", "LowerTorso", "RightUpperLeg", LowerTorsoCFrame, RightUpperLegCFrame)
    self:SetTransform("RightKnee", "RightKneeRigAttachment", "RightUpperLeg", "RightLowerLeg", RightUpperLegCFrame, RightLowerLegCFrame)
    self:SetTransform("RightAnkle", "RightAnkleRigAttachment", "RightLowerLeg", "RightFoot", RightLowerLegCFrame, RightFootCFrame)
    self:SetTransform("LeftHip", "LeftHipRigAttachment", "LowerTorso", "LeftUpperLeg", LowerTorsoCFrame, LeftUpperLegCFrame)
    self:SetTransform("LeftKnee", "LeftKneeRigAttachment", "LeftUpperLeg", "LeftLowerLeg", LeftUpperLegCFrame, LeftLowerLegCFrame)
    self:SetTransform("LeftAnkle", "LeftAnkleRigAttachment", "LeftLowerLeg", "LeftFoot", LeftLowerLegCFrame, LeftFootCFrame)
    self:SetTransform("Neck", "NeckRigAttachment", "UpperTorso", "Head", UpperTorsoCFrame, HeadCFrame)
    self:SetTransform("Waist", "WaistRigAttachment", "LowerTorso", "UpperTorso", LowerTorsoCFrame, UpperTorsoCFrame)
    self:SetTransform("RightShoulder", "RightShoulderRigAttachment", "UpperTorso", "RightUpperArm", UpperTorsoCFrame, RightUpperArmCFrame)
    self:SetTransform("RightElbow", "RightElbowRigAttachment", "RightUpperArm", "RightLowerArm", RightUpperArmCFrame, RightLowerArmCFrame)
    self:SetTransform("RightWrist", "RightWristRigAttachment", "RightLowerArm", "RightHand", RightLowerArmCFrame, RightHandCFrame)
    self:SetTransform("LeftShoulder", "LeftShoulderRigAttachment", "UpperTorso", "LeftUpperArm", UpperTorsoCFrame, LeftUpperArmCFrame)
    self:SetTransform("LeftElbow", "LeftElbowRigAttachment", "LeftUpperArm", "LeftLowerArm", LeftUpperArmCFrame, LeftLowerArmCFrame)
    self:SetTransform("LeftWrist", "LeftWristRigAttachment", "LeftLowerArm", "LeftHand", LeftLowerArmCFrame, LeftHandCFrame)

    --Replicate the changes to the server.
    if Players.LocalPlayer and Players.LocalPlayer.Character == self.CharacterModel then
        self.ReplicationCFrames = {HeadControllerCFrame, LeftHandControllerCFrame, RightHandControllerCFrame}
    end
end

--[[
Updates the character from the inputs while seated.
The CFrames are in the local space instead of global space
since the seat maintains the global space.
--]]
function Character:UpdateFromInputsSeated(HeadControllerCFrame: CFrame, LeftHandControllerCFrame: CFrame, RightHandControllerCFrame: CFrame): ()
    --Return if the humanoid is dead.
    if self.Humanoid.Health <= 0 then
        return
    end

    --Get the CFrames.
    local HeadCFrame = self.Head:GetHeadCFrame(HeadControllerCFrame)
    local NeckCFrame = self.Head:GetNeckCFrame(HeadControllerCFrame,0)
	local LowerTorsoCFrame, UpperTorsoCFrame = self.Torso:GetTorsoCFrames(NeckCFrame)
	local JointCFrames = self.Torso:GetAppendageJointCFrames(LowerTorsoCFrame,UpperTorsoCFrame)
	local LeftUpperArmCFrame, LeftLowerArmCFrame, LeftHandCFrame = self.LeftArm:GetAppendageCFrames(JointCFrames["LeftShoulder"], LeftHandControllerCFrame)
	local RightUpperArmCFrame, RightLowerArmCFrame, RightHandCFrame = self.RightArm:GetAppendageCFrames(JointCFrames["RightShoulder"], RightHandControllerCFrame)
    local EyesOffset = self.Head:GetEyesOffset()
    local HeightOffset = CFrame.new(0, (CFrame.new(0, EyesOffset.Y, 0) * (HeadControllerCFrame * EyesOffset:Inverse())).Y, 0)

    --Set the head, toros, and arm CFrames.
    self:SetCFrameProperty(self.Motors.Root, "Transform", HeightOffset * CFrame.new(0, -LowerTorsoCFrame.Y, 0) * LowerTorsoCFrame)
    self:SetTransform("Neck", "NeckRigAttachment", "UpperTorso", "Head", UpperTorsoCFrame, HeadCFrame)
    self:SetTransform("Waist", "WaistRigAttachment", "LowerTorso", "UpperTorso", LowerTorsoCFrame, UpperTorsoCFrame)
    self:SetTransform("RightShoulder", "RightShoulderRigAttachment", "UpperTorso", "RightUpperArm", UpperTorsoCFrame, RightUpperArmCFrame)
    self:SetTransform("RightElbow", "RightElbowRigAttachment", "RightUpperArm", "RightLowerArm", RightUpperArmCFrame, RightLowerArmCFrame)
    self:SetTransform("RightWrist", "RightWristRigAttachment", "RightLowerArm", "RightHand", RightLowerArmCFrame, RightHandCFrame)
    self:SetTransform("LeftShoulder", "LeftShoulderRigAttachment", "UpperTorso", "LeftUpperArm", UpperTorsoCFrame, LeftUpperArmCFrame)
    self:SetTransform("LeftElbow", "LeftElbowRigAttachment", "LeftUpperArm", "LeftLowerArm", LeftUpperArmCFrame, LeftLowerArmCFrame)
    self:SetTransform("LeftWrist", "LeftWristRigAttachment", "LeftLowerArm", "LeftHand", LeftLowerArmCFrame, LeftHandCFrame)

    --Set the legs to be sitting.
    self.Motors.RightHip.Transform = CFrame.Angles(math.pi / 2, 0, math.rad(5))
    self.Motors.LeftHip.Transform = CFrame.Angles(math.pi / 2, 0, math.rad(-5))
    self.Motors.RightKnee.Transform = CFrame.Angles(math.rad(-10), 0, 0)
    self.Motors.LeftKnee.Transform = CFrame.Angles(math.rad(-10), 0, 0)
    self.Motors.RightAnkle.Transform = CFrame.Angles(0, 0, 0)
    self.Motors.LeftAnkle.Transform = CFrame.Angles(0, 0, 0)

    --Replicate the changes to the server.
    if Players.LocalPlayer and Players.LocalPlayer.Character == self.CharacterModel then
        self.ReplicationCFrames = {HeadControllerCFrame, LeftHandControllerCFrame, RightHandControllerCFrame}
    end
end



return (Character :: any) :: Character]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX24304227741747BEABB9708B7D4F8AEF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Appendage</string>
						<string name="ScriptGuid">{BC4687CE-1E87-44A0-93F3-EF6054CBA64E}</string>
						<ProtectedString name="Source"><![CDATA[ --[[
TheNexusAvenger

Stores information about an appendage, such as
an arm or a leg.
--]]

local Limb = require(script.Parent:WaitForChild("Limb"))

local Appendage = {}
Appendage.__index = Appendage
setmetatable(Appendage, Limb)



--[[
Creates an appendage.
--]]
function Appendage.new(UpperLimb: BasePart, LowerLimb: BasePart, LimbEnd: BasePart, StartAttachment: string, LimbJointAttachment: string, LimbEndAttachment: string, LimbHoldAttachment: string, PreventDisconnection: boolean?): any
    local self = Limb.new()
    self.UpperLimb = UpperLimb
    self.LowerLimb = LowerLimb
    self.LimbEnd = LimbEnd
    self.StartAttachment = StartAttachment
    self.LimbJointAttachment = LimbJointAttachment
    self.LimbEndAttachment = LimbEndAttachment
    self.LimbHoldAttachment = LimbHoldAttachment
    self.PreventDisconnection = PreventDisconnection or false
    return setmetatable(self, Appendage)
end

--[[
Attempts to solve a joint. This uses
the "naive" approach for inverse kinematics.
--]]
function Appendage:SolveJoint(OriginCFrame: CFrame, TargetPosition: Vector3, Length1: number, Length2: number): (CFrame, number, number)
    local LocalizedPosition = OriginCFrame:PointToObjectSpace(TargetPosition)
    local LocalizedUnit = LocalizedPosition.unit
    local Hypotenuse = LocalizedPosition.Magnitude

    --Get the axis and correct it if it is 0.
    local Axis = Vector3.new(0, 0, -1):Cross(LocalizedUnit)
    if Axis == Vector3.new(0, 0, 0) then
        if LocalizedPosition.Z < 0 then
            Axis = Vector3.new(0, 0, 0.001)
        else
            Axis = Vector3.new(0, 0, -0.001)
        end
    end

    --Calculate and return the angles.
    local PlaneRotation = math.acos(-LocalizedUnit.Z)
    local PlaneCFrame = OriginCFrame * CFrame.fromAxisAngle(Axis, PlaneRotation)
    if Hypotenuse < math.max(Length2, Length1) - math.min(Length2, Length1) then
        local ShoulderAngle, ElbowAngle = -math.pi / 2, math.pi
        if self.PreventDisconnection then
            return PlaneCFrame, ShoulderAngle, ElbowAngle
        else
            return PlaneCFrame * CFrame.new(0, 0, math.max(Length2, Length1) - math.min(Length2, Length1) - Hypotenuse), ShoulderAngle, ElbowAngle
        end
    elseif Hypotenuse > Length1 + Length2 then
        local ShoulderAngle, ElbowAngle = math.pi / 2, 0
        if self.PreventDisconnection then
            return PlaneCFrame, ShoulderAngle, ElbowAngle
        else
            return PlaneCFrame * CFrame.new(0, 0, Length1 + Length2 - Hypotenuse), ShoulderAngle, ElbowAngle
        end
    else
        local Angle1 = -math.acos((-(Length2 * Length2) + (Length1 * Length1) + (Hypotenuse * Hypotenuse)) / (2 * Length1 * Hypotenuse))
        local Angle2 = math.acos(((Length2  * Length2) - (Length1 * Length1) + (Hypotenuse * Hypotenuse)) / (2 * Length2 * Hypotenuse))
        if self.InvertBendDirection then
            Angle1 = -Angle1
            Angle2 = -Angle2
        end
        return PlaneCFrame , Angle1 + math.pi / 2, Angle2 - Angle1
    end
end

--[[
Returns the rotation offset relative to the Y axis
to an end CFrame.
--]]
function Appendage:RotationTo(StartCFrame: CFrame, EndCFrame: CFrame): CFrame
	local Offset = (StartCFrame:Inverse() * EndCFrame).Position
	return CFrame.Angles(math.atan2(Offset.Z, Offset.Y), 0, -math.atan2(Offset.X, Offset.Y))
end

--[[
Returns the CFrames of the appendage for
the starting and holding CFrames. The implementation
works, but could be improved.
--]]
function Appendage:GetAppendageCFrames(StartCFrame: CFrame, HoldCFrame: CFrame): (CFrame, CFrame, CFrame)
    --Get the attachment CFrames.
    local LimbHoldCFrame = self:GetAttachmentCFrame(self.LimbEnd, self.LimbHoldAttachment)
    local LimbEndCFrame = self:GetAttachmentCFrame(self.LimbEnd, self.LimbEndAttachment)
    local UpperLimbStartCFrame = self:GetAttachmentCFrame(self.UpperLimb, self.StartAttachment)
    local UpperLimbJointCFrame = self:GetAttachmentCFrame(self.UpperLimb, self.LimbJointAttachment)
    local LowerLimbJointCFrame = self:GetAttachmentCFrame(self.LowerLimb, self.LimbJointAttachment)
    local LowerLimbEndCFrame = self:GetAttachmentCFrame(self.LowerLimb, self.LimbEndAttachment)

    --Calculate the appendage lengths.
    local UpperLimbLength = (UpperLimbStartCFrame.Position - UpperLimbJointCFrame.Position).magnitude
    local LowerLimbLength = (LowerLimbJointCFrame.Position - LowerLimbEndCFrame.Position).magnitude

    --Calculate the end point of the limb.
    local AppendageEndJointCFrame = HoldCFrame * LimbHoldCFrame:Inverse() * LimbEndCFrame

    --Solve the join.
    local PlaneCFrame,UpperAngle,CenterAngle = self:SolveJoint(StartCFrame, AppendageEndJointCFrame.Position, UpperLimbLength, LowerLimbLength)

    --Calculate the CFrame of the limb join before and after the center angle.
    local JointUpperCFrame = PlaneCFrame * CFrame.Angles(UpperAngle, 0, 0) * CFrame.new(0, -UpperLimbLength, 0)
    local JointLowerCFrame = JointUpperCFrame * CFrame.Angles(CenterAngle, 0, 0)

    --Calculate the part CFrames.
    --The appendage end is not calculated with hold CFrame directly since it can ignore PreventDisconnection = true.
    local UpperLimbCFrame = JointUpperCFrame * self:RotationTo(UpperLimbJointCFrame, UpperLimbStartCFrame):Inverse() * UpperLimbJointCFrame:Inverse()
    local LowerLimbCFrame = JointLowerCFrame * self:RotationTo(LowerLimbEndCFrame, LowerLimbJointCFrame):Inverse() * LowerLimbJointCFrame:Inverse()
    local AppendageEndCFrame = CFrame.new((LowerLimbCFrame * LowerLimbEndCFrame).Position) * (CFrame.new(-AppendageEndJointCFrame.Position) * AppendageEndJointCFrame) * LimbEndCFrame:Inverse()

    --Return the part CFrames.
    return UpperLimbCFrame, LowerLimbCFrame, AppendageEndCFrame
end



return Appendage]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXAE969A9F2EDF44CEBC031050B49A9CA7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Camera</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX42AEA0A31C164E99977C8856056697F6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">DefaultCamera</string>
							<string name="ScriptGuid">{7182F63B-E439-4A07-828B-72AF5D0663D4}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Default camera that follows the character.
--]]
--!strict

local BUMP_DEFAULT_TRANSPARENCY_WORKAROUND = true
local HIDDEN_ACCESSORIES = {
    [Enum.AccessoryType.Hat] = true;
    [Enum.AccessoryType.Hair] = true;
    [Enum.AccessoryType.Face] = true;
    [Enum.AccessoryType.Eyebrow] = true;
    [Enum.AccessoryType.Eyelash] = true;
}

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local DefaultCamera = {}
DefaultCamera.__index = DefaultCamera



--[[
Returns true if the provided part should be hidden in first person.
--]]
function DefaultCamera.ShouldHidePart(Part: BasePart): boolean
    local Parent: Instance? = Part.Parent
    if Parent then
        if Parent:IsA("Accessory") then
            local AccessoryType = Parent.AccessoryType
            return HIDDEN_ACCESSORIES[AccessoryType] or false
        elseif Parent:IsA("Model") then
            return false
        else
            return not Parent:IsA("Tool")
        end
    end

    if Part:FindFirstChildWhichIsA("WrapLayer") then
        return false
    end

    return true
end

--[[
Returns true if the provided part is in a tool.
--]]
function DefaultCamera.IsInTool(Part: Instance): boolean
    while Part do
        if Part:IsA("Tool") then
            return true
        end
        Part = (Part :: any).Parent
    end
    return false
end

--[[
Creates a default camera object.
--]]
function DefaultCamera.new(): any
    return setmetatable({}, DefaultCamera)
end

--[[
Enables the camera.
--]]
function DefaultCamera:Enable(): ()
    self.TransparencyEvents = {}
    if Players.LocalPlayer.Character then
        --Connect children being added.
        local Transparency = Settings:GetSetting("Appearance.LocalCharacterTransparency")
        if BUMP_DEFAULT_TRANSPARENCY_WORKAROUND then
            if Transparency == 0.5 then
                Transparency = 0.501
            elseif Transparency < 0.5 then
                warn("Values of <0.5 with Appearance.LocalCharacterTransparency are currently known to cause black screen issues. This will hopefully be resolved by Roblox in a future update: https://devforum.roblox.com/t/vr-screen-becomes-black-due-to-non-transparent-character/2215099")
            end
        end
        table.insert(self.TransparencyEvents, Players.LocalPlayer.Character.DescendantAdded:Connect(function(Part)
            if Part:IsA("BasePart") then
                if DefaultCamera.ShouldHidePart(Part) then
                    Part.LocalTransparencyModifier = 1
                elseif DefaultCamera.IsInTool(Part) then
                    Part.LocalTransparencyModifier = 0
                else
                    Part.LocalTransparencyModifier = Transparency
                    table.insert(self.TransparencyEvents, Part:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                        Part.LocalTransparencyModifier = Transparency
                    end))
                end
            end
        end))
        for _, Part in Players.LocalPlayer.Character:GetDescendants() do
            if Part:IsA("BasePart") then
                if DefaultCamera.ShouldHidePart(Part) then
                    Part.LocalTransparencyModifier = 1
                elseif DefaultCamera.IsInTool(Part) then
                    Part.LocalTransparencyModifier = 0
                else
                    Part.LocalTransparencyModifier = Transparency
                    table.insert(self.TransparencyEvents, Part:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                        Part.LocalTransparencyModifier = Transparency
                    end))
                end
            end
        end
    end

    --Connect the character and local transparency changing.
    table.insert(self.TransparencyEvents, Players.LocalPlayer:GetPropertyChangedSignal("Character"):Connect(function()
        self:Disable()
        self:Enable()
    end))
    table.insert(self.TransparencyEvents, Settings:GetSettingsChangedSignal("Appearance.LocalCharacterTransparency"):Connect(function()
        self:Disable()
        self:Enable()
    end))
end

--[[
Disables the camera.
--]]
function DefaultCamera:Disable(): ()
    --Disconnect the character events.
    if self.TransparencyEvents then
        for _, Event in self.TransparencyEvents do
            Event:Disconnect()
        end
        self.TransparencyEvents = {}
    end

    --Reset the local transparency modifiers.
    if Players.LocalPlayer.Character then
        for _, Part in Players.LocalPlayer.Character:GetDescendants() do
            if Part:IsA("BasePart") then
                Part.LocalTransparencyModifier = 0
            end
        end
    end
end

--[[
Updates the camera.
--]]
function DefaultCamera:UpdateCamera(HeadsetCFrameWorld: CFrame): ()
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    Workspace.CurrentCamera.HeadLocked = false
    Workspace.CurrentCamera.CFrame = HeadsetCFrameWorld
end



return DefaultCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF546A761F6004093BC80C5A3FE53A31E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ThirdPersonTrackCamera</string>
							<string name="ScriptGuid">{9C085F80-D185-4B8C-B773-8ED795967C16}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Third person camera that moves with the player.
--]]
--!strict

local THIRD_PERSON_ZOOM = 10



local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local ThirdPersonTrackCamera = {}
ThirdPersonTrackCamera.__index = ThirdPersonTrackCamera



--[[
Creates a third-person camera object.
--]]
function ThirdPersonTrackCamera.new(): any
    return setmetatable({}, ThirdPersonTrackCamera)
end

--[[
Enables the camera.
--]]
function ThirdPersonTrackCamera:Enable(): ()
    self.FetchInitialCFrame = true
end

--[[
Disables the camera.
--]]
function ThirdPersonTrackCamera:Disable(): ()
    self.FetchInitialCFrame = nil
end

--[[
Updates the camera.
--]]
function ThirdPersonTrackCamera:UpdateCamera(HeadsetCFrameWorld: CFrame): ()
    --Set the initial CFrame to use.
    if self.FetchInitialCFrame then
        self.BaseFaceAngleY = math.atan2(-HeadsetCFrameWorld.LookVector.X, -HeadsetCFrameWorld.LookVector.Z)
        self.BaseCFrame = CFrame.new(HeadsetCFrameWorld.Position) * CFrame.Angles(0, self.BaseFaceAngleY, 0)
        self.FetchInitialCFrame = nil
    end

    --Get the scale.
    local Scale = 1
    local Character = Players.LocalPlayer.Character
    if Character then
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            local BodyHeightScale = Humanoid:FindFirstChild("BodyHeightScale")
            if BodyHeightScale then
                Scale = BodyHeightScale.Value
            end
        end
    end

    --Calculate the third person CFrame.
    local HeadsetRelative = self.BaseCFrame:Inverse() * HeadsetCFrameWorld
    local TargetCFrame = self.BaseCFrame * CFrame.new(0, 0, -THIRD_PERSON_ZOOM * Scale) * CFrame.Angles(0, math.pi, 0) * HeadsetRelative

    --Update the camaera.
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    Workspace.CurrentCamera.HeadLocked = false
    Workspace.CurrentCamera.CFrame = TargetCFrame
end



return ThirdPersonTrackCamera]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX4866B8B8D558451EAD4474FF2AC75B63">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Controller</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA277C10B3D9540B6A20384127E20A41A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseController</string>
							<string name="ScriptGuid">{68A49ACD-AA36-4BE7-A730-45C67E4067C8}</string>
							<ProtectedString name="Source"><![CDATA[ --[[
TheNexusAvenger

Base class for controlling the local character.
--]]
--!strict

local THUMBSTICK_INPUT_START_RADIUS = 0.6
local THUMBSTICK_INPUT_RELEASE_RADIUS = 0.4
local THUMBSTICK_DEADZONE_RADIUS = 0.2

local BLUR_TWEEN_INFO = TweenInfo.new(0.25, Enum.EasingStyle.Quad)

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
local CharacterService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CharacterService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local BaseController = {}
BaseController.__index = BaseController



--[[
Returns the Y-axis angle of the given CFrame.
--]]
local function GetAngleToGlobalY(CF: CFrame): number
    return math.atan2(-CF.LookVector.X, -CF.LookVector.Z)
end



--[[
Creates a base controller object.
--]]
function BaseController.new(): any
    return setmetatable({}, BaseController)
end

--[[
Updates the character. Returns if it changed.
--]]
function BaseController:UpdateCharacterReference(): boolean
    local LastCharacter = self.Character
    self.Character = CharacterService:GetCharacter(Players.LocalPlayer)
    if not self.Character then
        return false
    end
    return LastCharacter ~= self.Character
end

--[[
Enables the controller.
--]]
function BaseController:Enable(): ()
    if not self.Connections then self.Connections = {} end

    --Update the character and return if the character is nil.
    self:UpdateCharacterReference()
    if not self.Character then
        return
    end

    --Connect the eye level being set.
    table.insert(self.Connections, VRInputService.EyeLevelSet:Connect(function()
        if self.LastHeadCFrame.Y > 0 then
            self.LastHeadCFrame = CFrame.new(0, -self.LastHeadCFrame.Y, 0) * self.LastHeadCFrame
        end
    end))

    --Connect the character entering a seat.
    table.insert(self.Connections, self.Character.Humanoid:GetPropertyChangedSignal("SeatPart"):Connect(function()
        local SeatPart = self.Character:GetHumanoidSeatPart()
        if SeatPart then
            self:PlayBlur()
            VRInputService:Recenter()
        end
    end))

    --Disable auto rotate so that the default controls work.
    self.Character.Humanoid.AutoRotate = false

    --Disable the controls.
    --Done in a loop to ensure changed controllers are disabled.
    task.spawn(function()
        local ControlModule = require(Players.LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("ControlModule")) :: any
        local Character = self.Character
        while self.Character == Character and Character.Humanoid.Health > 0 do
            if ControlModule.activeController and ControlModule.activeController.enabled then
                ControlModule:Disable()
                ContextActionService:BindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
            end
            task.wait()
        end
    end)
end

--[[
Disables the controller.
--]]
function BaseController:Disable(): ()
    self.Character = nil
    self.LastHeadCFrame = nil
    for _, Connection in self.Connections do
        Connection:Disconnect()
    end
    self.Connections = nil
end

--[[
Scales the local-space input CFrame based on
the height multiplier of the character.
--]]
function BaseController:ScaleInput(InputCFrame: CFrame): CFrame
    --Return the original CFrame if there is no character.
    if not self.Character or not InputCFrame then
        return InputCFrame
    end

    --Return the modified CFrame.
    return CFrame.new(InputCFrame.Position * (self.Character.ScaleValues.BodyHeightScale.Value - 1)) * InputCFrame
end

--[[
Updates the provided 'Store' table with the state of its
Thumbstick (Enum.KeyCode.ThumbstickX) field. Returns the
direction state, radius state, and overall state change.
--]]
function BaseController:GetJoystickState(Store: any): (string, string, string)
    local InputPosition = VRInputService:GetThumbstickPosition(Store.Thumbstick)
    local InputRadius = ((InputPosition.X ^ 2) + (InputPosition.Y ^ 2)) ^ 0.5
    local InputAngle = math.atan2(InputPosition.X, InputPosition.Y)

    local DirectionState, RadiusState
    if InputAngle >= math.rad(-135) and InputAngle <= math.rad(-45) then
        DirectionState = "Left"
    elseif InputAngle >= math.rad(-45) and InputAngle <= math.rad(45) then
        DirectionState = "Forward"
    elseif InputAngle >= math.rad(45) and InputAngle <= math.rad(135) then
        DirectionState = "Right"
    end
    if InputRadius >= THUMBSTICK_INPUT_START_RADIUS then
        RadiusState = "Extended"
    elseif InputRadius <= THUMBSTICK_INPUT_RELEASE_RADIUS then
        RadiusState = "Released"
    else
        RadiusState = "InBetween"
    end

    --Update the stored state.
    local StateChange = nil
    if RadiusState == "Released" then
        if Store.RadiusState == "Extended" then
            StateChange = "Released"
        end
        Store.RadiusState = "Released"
        Store.DirectionState = nil
    elseif RadiusState == "Extended" then
        if Store.RadiusState == nil or Store.RadiusState == "Released" then
            if Store.RadiusState ~= "Extended" then
                StateChange = "Extended"
            end
            Store.RadiusState = "Extended"
            Store.DirectionState = DirectionState
        elseif Store.DirectionState ~= DirectionState then
            if Store.RadiusState ~= "Cancelled" then
                StateChange = "Cancel"
            end
            Store.RadiusState = "Cancelled"
            Store.DirectionState = nil
        end
    end

    return DirectionState, RadiusState, StateChange
end

--[[
Plays a temporary blur effect to make
teleports and snap turns less jarring.
]]--
function BaseController:PlayBlur(): ()
    local SnapTeleportBlur = Settings:GetSetting("Movement.SnapTeleportBlur")
    SnapTeleportBlur = (if SnapTeleportBlur == nil then true else SnapTeleportBlur)

    if not SnapTeleportBlur then
        return
    end

    local Blur = Instance.new("BlurEffect")
    Blur.Parent = workspace.CurrentCamera
    Blur.Size = 56

    local BlurTween = TweenService:Create(Blur, BLUR_TWEEN_INFO, { Size = 0 })
    BlurTween:Play()

    BlurTween.Completed:Connect(function()
        Blur:Destroy()
    end)
end

--[[
Updates the reference world CFrame.
--]]
function BaseController:UpdateCharacter(): ()
    --Return if the character is nil.
    local CharacterChanged = self:UpdateCharacterReference()
    if not self.Character then
        return
    end
    if CharacterChanged then
        self:Enable()
    end
    self.Character.TweenComponents = false

    --Get the VR inputs.
    local VRInputs = VRInputService:GetVRInputs()
    local VRHeadCFrame = self:ScaleInput(VRInputs[Enum.UserCFrame.Head])
    local VRLeftHandCFrame,VRRightHandCFrame = self:ScaleInput(VRInputs[Enum.UserCFrame.LeftHand]), self:ScaleInput(VRInputs[Enum.UserCFrame.RightHand])
    local HeadToLeftHandCFrame = VRHeadCFrame:Inverse() * VRLeftHandCFrame
    local HeadToRightHandCFrame = VRHeadCFrame:Inverse() * VRRightHandCFrame

    --Update the character.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    if not SeatPart then
        --Offset the character by the change in the head input.
        if self.LastHeadCFrame then
            --Get the eye CFrame of the current character, except the Y offset from the HumanoidRootPart.
            --The Y position will be added absolutely since doing it relatively will result in floating or short characters.
            local HumanoidRootPartCFrame = self.Character.Parts.HumanoidRootPart.CFrame
            local LowerTorsoCFrame = HumanoidRootPartCFrame * self.Character.Attachments.HumanoidRootPart.RootRigAttachment.CFrame * CFrame.new(0, -self.Character.Motors.Root.Transform.Position.Y, 0) * self.Character.Motors.Root.Transform * self.Character.Attachments.LowerTorso.RootRigAttachment.CFrame:Inverse()
            local UpperTorsoCFrame = LowerTorsoCFrame * self.Character.Attachments.LowerTorso.WaistRigAttachment.CFrame * self.Character.Motors.Waist.Transform * self.Character.Attachments.UpperTorso.WaistRigAttachment.CFrame:Inverse()
            local HeadCFrame = UpperTorsoCFrame * self.Character.Attachments.UpperTorso.NeckRigAttachment.CFrame * self.Character.Motors.Neck.Transform * self.Character.Attachments.Head.NeckRigAttachment.CFrame:Inverse()
            local EyesOffset = self.Character.Head:GetEyesOffset()
            local CharacterEyeCFrame = HeadCFrame * EyesOffset

            --Determine the input components.
            local InputDelta = self.LastHeadCFrame:Inverse() * VRHeadCFrame
            if VRHeadCFrame.UpVector.Y < 0 then
                InputDelta = CFrame.Angles(0,math.pi,0) * InputDelta
            end
            local HeadRotationXZ = (CFrame.new(VRHeadCFrame.Position) * CFrame.Angles(0, math.atan2(-VRHeadCFrame.LookVector.X, -VRHeadCFrame.LookVector.Z), 0)):Inverse() * VRHeadCFrame
            local LastHeadAngleY = GetAngleToGlobalY(self.LastHeadCFrame)
            local HeadAngleY = GetAngleToGlobalY(VRHeadCFrame)
            local HeightOffset = CFrame.new(0, (CFrame.new(0, EyesOffset.Y, 0) * (VRHeadCFrame * EyesOffset:Inverse())).Y, 0)

            --Offset the character eyes for the current input.
            local CurrentCharacterAngleY = GetAngleToGlobalY(CharacterEyeCFrame)
            local RotationY = CFrame.Angles(0, CurrentCharacterAngleY + (HeadAngleY - LastHeadAngleY), 0)
            local NewCharacterEyePosition = (HeightOffset *  CFrame.new((RotationY * CFrame.new(InputDelta.X, 0, InputDelta.Z)).Position) * CharacterEyeCFrame).Position
            local NewCharacterEyeCFrame = CFrame.new(NewCharacterEyePosition) * RotationY * HeadRotationXZ

            --Update the character.
            self.Character:UpdateFromInputs(NewCharacterEyeCFrame, NewCharacterEyeCFrame * HeadToLeftHandCFrame,NewCharacterEyeCFrame * HeadToRightHandCFrame)
        end
    else
        --Set the absolute positions of the character.
        self.Character:UpdateFromInputsSeated(VRHeadCFrame, VRHeadCFrame * HeadToLeftHandCFrame,VRHeadCFrame * HeadToRightHandCFrame)
    end
    self.LastHeadCFrame = VRHeadCFrame

    --Update the camera.
    if self.Character.Parts.HumanoidRootPart:IsDescendantOf(Workspace) and self.Character.Humanoid.Health > 0 then
        --Update the camera based on the character.
        --Done based on the HumanoidRootPart instead of the Head because of Motors not updating the same frame, leading to a delay.
        local HumanoidRootPartCFrame = self.Character.Parts.HumanoidRootPart.CFrame
        local LowerTorsoCFrame = HumanoidRootPartCFrame * self.Character.Attachments.HumanoidRootPart.RootRigAttachment.CFrame * self.Character.Motors.Root.Transform * self.Character.Attachments.LowerTorso.RootRigAttachment.CFrame:Inverse()
        local UpperTorsoCFrame = LowerTorsoCFrame * self.Character.Attachments.LowerTorso.WaistRigAttachment.CFrame * self.Character.Motors.Waist.Transform * self.Character.Attachments.UpperTorso.WaistRigAttachment.CFrame:Inverse()
        local HeadCFrame = UpperTorsoCFrame * self.Character.Attachments.UpperTorso.NeckRigAttachment.CFrame * self.Character.Motors.Neck.Transform * self.Character.Attachments.Head.NeckRigAttachment.CFrame:Inverse()
        CameraService:UpdateCamera(HeadCFrame * self.Character.Head:GetEyesOffset())
    else
        --Update the camera based on the last CFrame if the motors can't update (not in Workspace).
        local CurrentCameraCFrame = Workspace.CurrentCamera.CFrame
        local LastHeadCFrame = self.LastHeadCFrame or CFrame.new()
        local HeadCFrame = self:ScaleInput(VRInputService:GetVRInputs()[Enum.UserCFrame.Head])
        Workspace.CurrentCamera.CFrame = CurrentCameraCFrame * LastHeadCFrame:Inverse() * HeadCFrame
        self.LastHeadCFrame = HeadCFrame
    end
end

--[[
Updates the values of the vehicle seat.
--]]
function BaseController:UpdateVehicleSeat(): ()
    --Get the vehicle seat.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    if not SeatPart or not SeatPart:IsA("VehicleSeat") then
        return
    end

    --Get the direction.
    local ThumbstickPosition = VRInputService:GetThumbstickPosition(Enum.KeyCode.Thumbstick1)
    if ThumbstickPosition.Magnitude < THUMBSTICK_DEADZONE_RADIUS then
        ThumbstickPosition = Vector3.zero
    end
    local ForwardDirection = (UserInputService:IsKeyDown(Enum.KeyCode.W) and 1 or 0) + (UserInputService:IsKeyDown(Enum.KeyCode.S) and -1 or 0) + ThumbstickPosition.Y
    local SideDirection = (UserInputService:IsKeyDown(Enum.KeyCode.D) and 1 or 0) + (UserInputService:IsKeyDown(Enum.KeyCode.A) and -1 or 0) + ThumbstickPosition.X

    --Update the throttle and steering.
    SeatPart.ThrottleFloat = ForwardDirection
    SeatPart.SteerFloat = SideDirection
end



return BaseController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2E60C604993746D6B5D7C60A05CCD196">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SmoothLocomotionController</string>
							<string name="ScriptGuid">{AC08508A-BAD8-41DF-9EC7-EEAA01E199E3}</string>
							<ProtectedString name="Source"><![CDATA[ --[[
TheNexusAvenger

Local character controller using teleporting.
--]]
--!strict

local THUMBSTICK_MANUAL_ROTATION_ANGLE = math.rad(45)
local THUMBSTICK_DEADZONE_RADIUS = 0.2



local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusVRCharacterModelApi = require(NexusVRCharacterModel).Api
local BaseController = require(script.Parent:WaitForChild("BaseController"))
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local SmoothLocomotionController = {}
SmoothLocomotionController.__index = SmoothLocomotionController
setmetatable(SmoothLocomotionController, BaseController)



--[[
Creates a smooth locomotion controller object.
--]]
function SmoothLocomotionController.new(): any
    return setmetatable(BaseController.new(), SmoothLocomotionController)
end

--[[
Enables the controller.
--]]
function SmoothLocomotionController:Enable(): ()
    BaseController.Enable(self)
    self.JoystickState = { Thumbstick = Enum.KeyCode.Thumbstick2 }

    --Connect requesting jumping.
    --ButtonA does not work with IsButtonDown.
    self.ButtonADown = false
    table.insert(self.Connections, UserInputService.InputBegan:Connect(function(Input, Processsed)
        if Processsed then return end
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = true
        end
    end))
    table.insert(self.Connections, UserInputService.InputEnded:Connect(function(Input)
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = false
        end
    end))
end

--[[
Disables the controller.
--]]
function SmoothLocomotionController:Disable(): ()
    BaseController.Disable(self)
    self.JoystickState = nil
end

--[[
Updates the local character. Must also update the camara.
--]]
function SmoothLocomotionController:UpdateCharacter(): ()
    --Update the base character.
    BaseController.UpdateCharacter(self)
    if not self.Character then
        return
    end

    --Determine the direction to move the player.
    local ThumbstickPosition = VRInputService:GetThumbstickPosition(Enum.KeyCode.Thumbstick1)
    local LeftHandInputActive = (not NexusVRCharacterModelApi.Controller or NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(Enum.UserCFrame.LeftHand))
    local RightHandInputActive = (not NexusVRCharacterModelApi.Controller or NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(Enum.UserCFrame.RightHand))
    if ThumbstickPosition.Magnitude < THUMBSTICK_DEADZONE_RADIUS or not LeftHandInputActive then
        ThumbstickPosition = Vector3.zero
    end
    local WDown, SDown = not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.W), not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.S)
    local DDown, ADown = not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.D), not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.A)
    local ForwardDirection = (WDown and 1 or 0) + (SDown and -1 or 0) + ThumbstickPosition.Y
    local SideDirection = (DDown and 1 or 0) + (ADown and -1 or 0) + ThumbstickPosition.X

    --Move the player in that direction.
    Players.LocalPlayer:Move(Vector3.new(SideDirection, 0, -ForwardDirection), true)

    --Snap rotate the character.
    if not self.Character.Humanoid.Sit then
        --Update and fetch the right joystick's state.
        local DirectionState, _, StateChange = self:GetJoystickState(self.JoystickState)

        --Snap rotate the character.
        local HumanoidRootPart = self.Character.Parts.HumanoidRootPart
        if StateChange == "Extended" and RightHandInputActive then
            if DirectionState == "Left" then
                --Turn the player to the left.
                self:PlayBlur()
                HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, THUMBSTICK_MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
            elseif DirectionState == "Right" then
                --Turn the player to the right.
                self:PlayBlur()
                HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, -THUMBSTICK_MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
            end
        end
    end

    --Update the vehicle seat.
    self:UpdateVehicleSeat()

    --Jump the player.
    if (not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.Space)) or self.ButtonADown then
        self.Character.Humanoid.Jump = true
    end
end



return SmoothLocomotionController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX708721741CFE471291547DE5918B626C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TeleportController</string>
							<string name="ScriptGuid">{84174D07-49B2-4FEF-BDDA-90D5EDB98DF2}</string>
							<ProtectedString name="Source"><![CDATA[ --[[
TheNexusAvenger

Local character controller using teleporting.
--]]
--!strict

local IGNORE_RIGHT_INPUT_FORWARD_ON_MENU_OPEN = true
local THUMBSTICK_MANUAL_ROTATION_ANGLE = math.rad(45)



local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusVRCharacterModelApi = require(NexusVRCharacterModel).Api
local BaseController = require(script.Parent:WaitForChild("BaseController"))
local ArcWithBeacon = require(script.Parent:WaitForChild("Visual"):WaitForChild("ArcWithBeacon"))
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local TeleportController = {}
TeleportController.__index = TeleportController
setmetatable(TeleportController, BaseController)



--[[
Creates a teleport controller object.
--]]
function TeleportController.new(): any
    return setmetatable(BaseController.new(), TeleportController)
end

--[[
Enables the controller.
--]]
function TeleportController:Enable(): ()
    BaseController.Enable(self)

    --Create the arcs.
    self.LeftArc = ArcWithBeacon.new()
    self.RightArc = ArcWithBeacon.new()
    self.ArcControls = {
        {
            Thumbstick = Enum.KeyCode.Thumbstick1,
            UserCFrame = Enum.UserCFrame.LeftHand,
            Arc = self.LeftArc,
        },
        {
            Thumbstick = Enum.KeyCode.Thumbstick2,
            UserCFrame = Enum.UserCFrame.RightHand,
            Arc = self.RightArc,
        },
    }

    --Connect requesting jumping.
    --ButtonA does not work with IsButtonDown.
    self.ButtonADown = false
    table.insert(self.Connections, UserInputService.InputBegan:Connect(function(Input, Processsed)
        if Processsed then return end
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = true
        end
    end))
    table.insert(self.Connections, UserInputService.InputEnded:Connect(function(Input)
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = false
        end
    end))
end

--[[
Disables the controller.
--]]
function TeleportController:Disable(): ()
    BaseController.Disable(self)

    --Destroy the arcs.
    self.LeftArc:Destroy()
    self.RightArc:Destroy()
end

--[[
Updates the local character. Must also update the camara.
--]]
function TeleportController:UpdateCharacter(): ()
    --Update the base character.
    BaseController.UpdateCharacter(self)
    if not self.Character then
        return
    end

    --Get the VR inputs.
    local VRInputs = VRInputService:GetVRInputs()
    for _, InputEnum in Enum.UserCFrame:GetEnumItems() do
        VRInputs[InputEnum] = self:ScaleInput(VRInputs[InputEnum])
    end

    --Update the arcs.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    for _, ArcData in self.ArcControls do
        --Reset the left arc if the player is in a vehicle seat.
        if ArcData.Thumbstick == Enum.KeyCode.Thumbstick1 and SeatPart and SeatPart:IsA("VehicleSeat") then
            ArcData.Arc:Hide()
            continue
        end

        --Update and fetch the current state.
        local InputActive = (not NexusVRCharacterModelApi.Controller or NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(ArcData.UserCFrame))
        local DirectionState, RadiusState, StateChange = self:GetJoystickState(ArcData)
        if not InputActive then
            ArcData.Arc:Hide()
            ArcData.WaitForRelease = false
            ArcData.RadiusState = nil
            continue
        end

        --Cancel the input if it is forward facing, on the right hand, and the menu is visible.
        --This is an optimization for the Valve Index that has pressing the right thumbstick forward for opening the menu.
        --PositionLocked only appears when a user is pointing at the main user interface. This will not work if the player toggles
        --the Roblox UI but doesn't point at it. Ideally, there should be a way to know that this input opens the Roblox UI.
        if IGNORE_RIGHT_INPUT_FORWARD_ON_MENU_OPEN and not ArcData.WaitForRelease and DirectionState == "Forward" and ArcData.Thumbstick == Enum.KeyCode.Thumbstick2 then
            local VRCorePanelParts = Workspace.CurrentCamera:FindFirstChild("VRCorePanelParts")
            if VRCorePanelParts then
                local PositionLocked = VRCorePanelParts:FindFirstChild("PositionLocked")
                if PositionLocked and PositionLocked.Position.Magnitude > 0.001 then
                    ArcData.WaitForRelease = true
                end
            end
        end
        if ArcData.WaitForRelease then
            if RadiusState == "Released" then
                ArcData.WaitForRelease = false
            else
                StateChange = "Cancel"
                ArcData.RadiusState = nil
            end
        end

        --Update from the state.
        local HumanoidRootPart = self.Character.Parts.HumanoidRootPart
        if DirectionState ~= "Forward" or RadiusState == "Released" then
            ArcData.Arc:Hide()
        end
        if StateChange == "Extended" then
            if not self.Character.Humanoid.Sit then
                if DirectionState == "Left" then
                    --Turn the player to the left.
                    self:PlayBlur()
                    HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, THUMBSTICK_MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                elseif DirectionState == "Right" then
                    --Turn the player to the right.
                    self:PlayBlur()
                    HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, -THUMBSTICK_MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                end
            end
        elseif StateChange == "Released" then
            ArcData.Arc:Hide()
            if DirectionState == "Forward" then
                --Teleport the player.
                if ArcData.LastHitPart and ArcData.LastHitPosition then
                    --Unsit the player.
                    --The teleport event is set to ignored since the CFrame will be different when the player gets out of the seat.
                    local WasSitting = false
                    self:PlayBlur()

                    if SeatPart then
                        WasSitting = true
                        self.IgnoreNextExternalTeleport = true
                        self.Character.Humanoid.Sit = false
                    end

                    if (ArcData.LastHitPart:IsA("Seat") or ArcData.LastHitPart:IsA("VehicleSeat")) and not ArcData.LastHitPart.Occupant and not ArcData.LastHitPart.Disabled then
                        --Sit in the seat.
                        --Waiting is done if the player was in an existing seat because the player no longer sitting will prevent sitting.
                        if WasSitting then
                            task.spawn(function()
                                while self.Character.Humanoid.SeatPart do task.wait() end
                                ArcData.LastHitPart:Sit(self.Character.Humanoid)
                            end)
                        else
                            ArcData.LastHitPart:Sit(self.Character.Humanoid)
                        end
                    else
                        --Teleport the player.
                        --Waiting is done if the player was in an existing seat because the player will teleport the seat.
                        if WasSitting then
                            task.spawn(function()
                                while self.Character.Humanoid.SeatPart do task.wait() end
                                HumanoidRootPart.CFrame = CFrame.new(ArcData.LastHitPosition) * CFrame.new(0, 4.5 * self.Character.ScaleValues.BodyHeightScale.Value, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                            end)
                        else
                            HumanoidRootPart.CFrame = CFrame.new(ArcData.LastHitPosition) * CFrame.new(0, 4.5 * self.Character.ScaleValues.BodyHeightScale.Value, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                        end
                    end
                end
            end
        elseif StateChange == "Cancel" then
            ArcData.Arc:Hide()
        elseif DirectionState == "Forward" and RadiusState == "Extended" then
            ArcData.LastHitPart, ArcData.LastHitPosition = ArcData.Arc:Update(Workspace.CurrentCamera:GetRenderCFrame() * VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[ArcData.UserCFrame])
        end
    end

    --Update the vehicle seat.
    self:UpdateVehicleSeat()

    --Jump the player.
    if (not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.Space)) or self.ButtonADown then
        self.Character.Humanoid.Jump = true
    end
end



return TeleportController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXD21A0403D2274CD3922F1BEA93765B71">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Visual</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5503888F86164BA3B9913F50D400D8CD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Arc</string>
								<string name="ScriptGuid">{8C9C3FBA-CFFF-4388-83A3-48314683131F}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Visual indicator aiming with an arc.
--]]
--!strict

local MAX_SEGMENTS = 100
local SEGMENT_SEPARATION = 2
local BASE_POINTER_ANGLE = math.rad(60)
local POINTER_PARABOLA_HEIGHT_MULTIPLIER = -0.2



local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent.Parent.Parent
local FindCollidablePartOnRay = require(NexusVRCharacterModel:WaitForChild("Util"):WaitForChild("FindCollidablePartOnRay"))

local Arc = {}
Arc.__index = Arc

export type Arc = {
    new: () -> (Arc),

    Update: (self: Arc, StartCFrame: CFrame) -> (BasePart?, Vector3?),
    Hide: (self: Arc) -> (),
    Destroy: (self: Arc) -> (),
}



--[[
Creates an arc.
--]]
function Arc.new(): Arc
    local self = setmetatable({
        BeamParts = {},
    }, Arc)
    self:Hide()
    return (self :: any) :: Arc
end

--[[
Updates the arc. Returns the part and
position that were hit.
--]]
function Arc:Update(StartCFrame: CFrame): (BasePart?, Vector3?)
    --Calculate the starting angle.
    local StartPosition = StartCFrame.Position
    local FaceAngle = math.atan2(-StartCFrame.LookVector.X, -StartCFrame.LookVector.Z)
    local StartAngle = math.asin(StartCFrame.LookVector.Y)
    StartAngle = StartAngle + (BASE_POINTER_ANGLE * ((math.pi / 2) - math.abs(StartAngle)) / (math.pi / 2))

    --Calculate the start CFrame and start offset of the parabola.
    --The start is the where the derivative of POINTER_PARABOLA_HEIGHT_MULTIPLIER * x^2 is tan(StartAngle).
    local StartCF = CFrame.new(StartPosition) * CFrame.Angles(0, FaceAngle, 0)
    local StartOffset = math.tan(StartAngle) / (POINTER_PARABOLA_HEIGHT_MULTIPLIER * 2)
    local StartValue = POINTER_PARABOLA_HEIGHT_MULTIPLIER * (StartOffset ^ 2)

    --Create the parts until the limit is reached.
    for i = 0, MAX_SEGMENTS - 1 do
        --Calculate the current and next position.
        local SegmentStartPosition = (StartCF * CFrame.new(0, POINTER_PARABOLA_HEIGHT_MULTIPLIER * ((i + StartOffset) ^ 2) - StartValue, -SEGMENT_SEPARATION * i)).Position
        local SegmentEndPosition = (StartCF * CFrame.new(0, POINTER_PARABOLA_HEIGHT_MULTIPLIER * ((i + 1 + StartOffset) ^ 2) - StartValue, -SEGMENT_SEPARATION * (i + 1))).Position

        --Create the parts if they don't exist.
        if not self.BeamParts[i] then
            self.BeamParts[i] = Instance.new("Part")
            self.BeamParts[i].Transparency = 1
            self.BeamParts[i].Size = Vector3.new(0, 0, 0)
            self.BeamParts[i].Anchored = true
            self.BeamParts[i].CanCollide = false
            self.BeamParts[i].Parent = Workspace.CurrentCamera

            local Attachment = Instance.new("Attachment")
            Attachment.Name = "BeamAttachment"
            Attachment.CFrame = CFrame.Angles(0, 0, math.pi / 2)
            Attachment.Parent = self.BeamParts[i]
        end
        if not self.BeamParts[i + 1] then
            --Create the part and attachment.
            self.BeamParts[i + 1] = Instance.new("Part")
            self.BeamParts[i + 1].Transparency = 1
            self.BeamParts[i + 1].Size = Vector3.new(0, 0, 0)
            self.BeamParts[i + 1].Anchored = true
            self.BeamParts[i + 1].CanCollide = false
            self.BeamParts[i + 1].Parent = Workspace.CurrentCamera

            local Attachment = Instance.new("Attachment")
            Attachment.Name = "BeamAttachment"
            Attachment.CFrame = CFrame.Angles(0, 0, math.pi / 2)
            Attachment.Parent = self.BeamParts[i + 1]

            --Create the beam.
            local Beam = Instance.new("Beam")
            Beam.Name = "Beam"
            Beam.Attachment0 = (self.BeamParts[i] :: any).BeamAttachment
            Beam.Attachment1 = Attachment
            Beam.Segments = 1
            Beam.Width0 = 0.1
            Beam.Width1 = 0.1
            Beam.Parent = self.BeamParts[i + 1]
        end

        --Cast the ray to the end.
        --Return if an end was hit and make the arc blue.
        local HitPart, HitPosition = FindCollidablePartOnRay(SegmentStartPosition, SegmentEndPosition - SegmentStartPosition, Players.LocalPlayer and Players.LocalPlayer.Character,Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart"))
        self.BeamParts[i].CFrame = CFrame.new(SegmentStartPosition) * CFrame.Angles(0, FaceAngle, 0);
        (self.BeamParts[i + 1] :: any).Beam.Enabled = true
        if HitPart then
            self.BeamParts[i + 1].CFrame = CFrame.new(HitPosition)
            for j = 0, i do
                (self.BeamParts[j + 1] :: any).Beam.Color = ColorSequence.new(Color3.fromRGB(0, 170, 255))
            end
            for j = i + 1, #self.BeamParts - 1 do
                (self.BeamParts[j + 1] :: any).Beam.Enabled = false
            end
            return HitPart, HitPosition
        else
            self.BeamParts[i + 1].CFrame = CFrame.new(SegmentEndPosition)
        end
    end

    --Set the beams to red.
    for i = 0, #self.BeamParts - 1 do
        (self.BeamParts[i + 1] :: any).Beam.Color = ColorSequence.new(Color3.fromRGB(200, 0, 0))
    end
    return nil, nil
end

--[[
Hides the arc.
--]]
function Arc:Hide(): ()
    for i = 0, #self.BeamParts - 1 do
        self.BeamParts[i + 1].Beam.Enabled = false
    end
end

--[[
Destroys the arc.
--]]
function Arc:Destroy(): ()
    for _, BeamPart in self.BeamParts do
        BeamPart:Destroy()
    end
    self.BeamParts = {}
end



return (Arc :: any) :: Arc]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX120085C4DD8748CF897D1B5A1676B6D5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ArcWithBeacon</string>
								<string name="ScriptGuid">{17AB8447-0829-4205-AE7C-A80989673B15}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Extension of the arc to add a beacon.
--]]
--!strict

local Arc = require(script.Parent:WaitForChild("Arc"))
local Beacon = require(script.Parent:WaitForChild("Beacon"))

local ArcWithBeacon = {}
ArcWithBeacon.__index = ArcWithBeacon
setmetatable(ArcWithBeacon, Arc)

export type ArcWithBeacon = {
    new: () -> (ArcWithBeacon),
} & Arc.Arc



--[[
Creates an arc.
--]]
function ArcWithBeacon.new(): ArcWithBeacon
    local self = Arc.new() :: any
    setmetatable(self, ArcWithBeacon)
    self.Beacon = Beacon.new()
    self:Hide()
    return self :: ArcWithBeacon
end

--[[
Updates the arc. Returns the part and
position that were hit.
--]]
function ArcWithBeacon:Update(StartCFrame: CFrame): (BasePart?, Vector3?)
    --Update the arc.
    local HitPart, HitPosition = Arc.Update(self, StartCFrame)

    --Update the beacon.
    local Beacon = (self :: any).Beacon :: Beacon.Beacon
    if HitPart then
        Beacon:Update(CFrame.new(HitPosition :: Vector3) * CFrame.new(0, 0.001, 0), HitPart)
    else
        Beacon:Hide()
    end

    --Return the arc's returns.
    return HitPart, HitPosition
end

--[[
Hides the arc.
--]]
function ArcWithBeacon:Hide(): ()
    Arc.Hide(self);
    (self :: any).Beacon:Hide()
end

--[[
Destroys the arc.
--]]
function ArcWithBeacon:Destroy(): ()
    Arc.Destroy(self);
    (self :: any).Beacon:Destroy()
end



return (ArcWithBeacon :: any) :: ArcWithBeacon]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFD764576F1214BBBBACFF860E9C1336D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Beacon</string>
								<string name="ScriptGuid">{0AB267E0-EB31-422A-AD29-4053F8AE3D40}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Visual indicator for the end of aiming.
--]]
--!strict

local BEACON_SPEED_MULTIPLIER = 2



local Workspace = game:GetService("Workspace")

local Beacon = {}
Beacon.__index = Beacon

export type Beacon = {
    new: () -> (Beacon),

    Update: (self: Beacon, CenterCFrame: CFrame, HoverPart: BasePart) -> (),
    Hide: (self: Beacon) -> (),
    Destroy: (self: Beacon) -> (),
}



--[[
Creates a beacon.
--]]
function Beacon.new(): Beacon
    --Create the object.
    local self = {}
    setmetatable(self, Beacon)

    --Create the parts.
    self.Sphere = Instance.new("Part")
    self.Sphere.Transparency = 1
    self.Sphere.Material = Enum.Material.Neon
    self.Sphere.Anchored = true
    self.Sphere.CanCollide = false
    self.Sphere.Size = Vector3.new(0.5, 0.5, 0.5)
    self.Sphere.Shape = Enum.PartType.Ball
    self.Sphere.Parent = Workspace.CurrentCamera

    self.ConstantRing = Instance.new("ImageHandleAdornment")
    self.ConstantRing.Adornee = self.Sphere
    self.ConstantRing.Size = Vector2.new(2, 2)
    self.ConstantRing.Image = "rbxasset://textures/ui/VR/VRPointerDiscBlue.png"
    self.ConstantRing.Visible = false
    self.ConstantRing.Parent = self.Sphere

    self.MovingRing = Instance.new("ImageHandleAdornment")
    self.MovingRing.Adornee = self.Sphere
    self.MovingRing.Size = Vector2.new(2, 2)
    self.MovingRing.Image = "rbxasset://textures/ui/VR/VRPointerDiscBlue.png"
    self.MovingRing.Visible = false
    self.MovingRing.Parent = self.Sphere

    --Return the object.
    return (self :: any) :: Beacon
end

--[[
Updates the beacon at a given CFrame.
--]]
function Beacon:Update(CenterCFrame: CFrame, HoverPart: BasePart): ()
    --Calculate the size for the current time.
    local Height = 0.4 + (-math.cos(tick() * 2 * BEACON_SPEED_MULTIPLIER) / 8)
    local BeaconSize = 2 * ((tick() * BEACON_SPEED_MULTIPLIER) % math.pi) / math.pi

    --Update the size and position of the beacon.
    self.Sphere.CFrame = CenterCFrame * CFrame.new(0, Height, 0)
    self.ConstantRing.CFrame = CFrame.new(0, -Height, 0) * CFrame.Angles(math.pi / 2, 0, 0)
    self.MovingRing.CFrame = CFrame.new(0, -Height, 0) * CFrame.Angles(math.pi / 2, 0, 0)
    self.MovingRing.Transparency = BeaconSize / 2
    self.MovingRing.Size = Vector2.new(BeaconSize, BeaconSize)

    --Update the beacon color.
    local BeaconColor = Color3.fromRGB(0, 170, 0)
    if HoverPart then
        local VRBeaconColor = HoverPart:FindFirstChild("VRBeaconColor") :: Color3Value
        if VRBeaconColor then
            BeaconColor = VRBeaconColor.Value
        elseif (HoverPart:IsA("Seat") or HoverPart:IsA("VehicleSeat")) and not HoverPart.Disabled then
            BeaconColor = Color3.fromRGB(0, 170, 255)
        end
    end
    self.Sphere.Color = BeaconColor

    --Show the beacon.
    self.Sphere.Transparency = 0
    self.ConstantRing.Visible = true
    self.MovingRing.Visible = true
end

--[[
Hides the beacon.
--]]
function Beacon:Hide(): ()
    --Hide the beacon.
    self.Sphere.Transparency = 1
    self.ConstantRing.Visible = false
    self.MovingRing.Visible = false
end

--[[
Destroys the beacon.
--]]
function Beacon:Destroy(): ()
    self.Sphere:Destroy()
end



return (Beacon :: any) :: Beacon]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXB99275FF4D6B4EA58F0A3B01697B78D9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FootPlanter</string>
						<string name="ScriptGuid">{43952FB2-546B-4DEA-BA2F-B1D0A988455D}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Attempts to solve footplanting.
This code is heavily "zombified" off of a project by
Stravant, and is taken from Nexus VR Character Model V1
with minimal changes. It really needs to be replaced by
someone who better unstands foot placement. No automated
tests are done on this code.
--]]

local FootPlanter = {}


local CFnew,CFAngles = CFrame.new,CFrame.Angles
local V3new = Vector3.new
local rad,atan2,acos = math.rad,math.atan2,math.acos
local min,max,abs,log = math.min,math.max,math.abs,math.log



function FootPlanter:CreateSolver(CenterPart,ScaleValue)
	--Heavily modified code from Stravant
	local FootPlanterClass = {}
	
	local ignoreModel = CenterPart.Parent
	
	local LEG_GAP = 1.2
	--
	local STRIDE_FORWARD = 1.7 / 2
	local STRIDE_BACKWARD = 3.3 / 2
	local STRIDE_HEIGHT = 0.6
	local STRIDE_RESTING = 1
	--
	local WALK_SPEED_VR_THRESHOLD = 2
	local FOOT_MAX_SPEED_FACTOR = 2
	--
	local WALK_CYCLE_POWER = 1
	--
	local FOOT_ANGLE = rad(5)
	
	
	
	local function flatten(CF)
		local X,Y,Z = CF.X,CF.Y,CF.Z
		local LX,LZ = CF.lookVector.X,CF.lookVector.Z
		
		return CFnew(X,Y,Z) * CFAngles(0,atan2(LX,LZ),0)
	end
	
	local lastPosition,lastPollTime
	local overrideVelocityWithZero = false
	local function getVelocity(CF)
		if overrideVelocityWithZero then
			overrideVelocityWithZero = true
			
			local curTime = tick()
			lastPosition = CF.p
			
			return V3new()
		end
		
		if lastPollTime then
			local curTime = tick()
			local newPosition = CF.p
			
			local velocity = (newPosition - lastPosition) * 1/(curTime - lastPollTime)
			lastPollTime = curTime
			lastPosition = newPosition
			
			return velocity
		else
			lastPollTime = tick()
			lastPosition = CF.p
			
			return V3new()
		end
	end
	
	local function getWalkSpeed(velocity)
		return V3new(velocity.x,0,velocity.z).magnitude
	end
	
	local function getWalkDirection(velocity)
		if velocity.magnitude > 0. then
			return velocity.unit
		else
			return V3new(0,0,-1)
		end
	end
	
	local function isWalking(velocity)
		return getWalkSpeed(velocity) > WALK_SPEED_VR_THRESHOLD
	end

	local CurrentScale = 1
	local function getBaseCFrame()
		return CenterPart.CFrame * CFnew(0,-CenterPart.Size.Y/2 - (CurrentScale * 2),0)
	end
	
	local function getBaseRotationY()
		local lookVector = getBaseCFrame().lookVector
		return atan2(lookVector.X,lookVector.Z)
	end
	
	local FindCollidablePartOnRay = require(script.Parent.Parent:WaitForChild("Util"):WaitForChild("FindCollidablePartOnRay"))
	local function FindPartOnRay(ray,ignore)
		return FindCollidablePartOnRay(ray.Origin,ray.Direction,ignore,CenterPart)
	end
	
	
	
	
	-- Leg data
	local mRightLeg, mLeftLeg, mRightArm, mLeftArm;
	local mLegs = {}
	local lastCF
	local function initLegs()
		local cf = flatten(getBaseCFrame(CenterPart.CFrame))
		lastCF = cf
		mRightLeg = {
			OffsetModifier = CFnew(-LEG_GAP/2, 0, 0);
			Side = -1;
			--
			StepCycle = 0;
			FootPosition = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			LastStepTo = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = cf*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mLeftLeg = {
			OffsetModifier = CFnew( LEG_GAP/2, 0, 0);
			Side = 1;
			--
			StepCycle = 0;
			FootPosition = cf*CFnew( LEG_GAP/2, 0, 0).p;
			LastStepTo = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = cf*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mRightLeg.OtherLeg = mLeftLeg
		mLeftLeg.OtherLeg = mRightLeg
		mLegs = {mLeftLeg, mRightLeg}
	end
	
	local LastScale = 1
	local function UpdateScaling()
		local Multiplier = ScaleValue.Value / LastScale
		LastScale = ScaleValue.Value

		LEG_GAP = LEG_GAP * Multiplier
		STRIDE_FORWARD = STRIDE_FORWARD * Multiplier
		STRIDE_BACKWARD = STRIDE_BACKWARD * Multiplier
		STRIDE_HEIGHT = STRIDE_HEIGHT * Multiplier
		STRIDE_RESTING = STRIDE_RESTING * Multiplier

		mRightLeg.OffsetModifier = CFnew(-LEG_GAP/2, 0, 0)
		--[[mRightLeg.FootPosition
		mRightLeg.LastStepTo
		mRightLeg.Takeoff
			 = ;
			Side = -1;
			--
			StepCycle = 0;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mLeftLeg = {
			OffsetModifier = CFnew( LEG_GAP/2, 0, 0);
			Side = 1;
			--
			StepCycle = 0;
			FootPosition = lastCF*CFnew( LEG_GAP/2, 0, 0).p;
			LastStepTo = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
		}]]
	end
	ScaleValue.Changed:Connect(function()
		if mRightLeg then
			UpdateScaling()
		end
	end)


	local mAirborneFraction = 0
	local mLandedFraction = 0
	local mCurrentSpeed = 1
	local mStableStanding = false
	
	local function getStrideForward()
		if mCurrentSpeed > 0 then
			return STRIDE_FORWARD + STRIDE_FORWARD*1*mCurrentSpeed
		else
			return STRIDE_FORWARD + STRIDE_FORWARD*0.5*mCurrentSpeed
		end
	end
	
	local function getStrideFull()
		if mCurrentSpeed > 0 then
			return (STRIDE_FORWARD + STRIDE_BACKWARD) + (STRIDE_FORWARD + STRIDE_BACKWARD)*1.5*mCurrentSpeed
		else
			return (STRIDE_FORWARD + STRIDE_BACKWARD) + (STRIDE_FORWARD + STRIDE_BACKWARD)*0.5*mCurrentSpeed
		end
	end

	local function snapDown(pos)
		local orig, dir = (pos + V3new(0, 2, 0)), V3new(0, -500, 0)
		local hit, at = FindPartOnRay(Ray.new(orig, dir), ignoreModel)
		if hit then
			local hit1, at1 = FindPartOnRay(Ray.new(orig + V3new(0,    0,  0.01), dir), ignoreModel)
			local hit2, at2 = FindPartOnRay(Ray.new(orig + V3new(0,    0, -0.01), dir), ignoreModel)				
			local hit3, at3 = FindPartOnRay(Ray.new(orig + V3new(0.01, 0,  0   ), dir), ignoreModel)
			local norm;
			
			if hit1 and hit2 and hit3 then
				norm = (at1 - at2):Cross(at2 - at3).unit
				if norm.Y < 0 then
					norm = -norm
				end					
			end
			
			return at, norm
		else
			return pos, V3new(0, 1, 0)
		end
	end
	
	local function fixFeetPositionsY()
		for _,leg in pairs(mLegs) do
			local targetPos,norm = snapDown(leg.FootPosition)
			leg.FootPosition = targetPos
		end
	end
	
	local lastTime
	function FootPlanterClass:GetFeetCFrames()
		if not mLeftLeg then
			initLegs()
			UpdateScaling()
		end
		
		local curTime = tick()
		if not lastTime then lastTime = curTime end
		local dt = curTime - lastTime
		lastTime = curTime
		
		local velocity = getVelocity(CenterPart.CFrame)
		local speed = getWalkSpeed(velocity)
		local realBaseCF = flatten(CenterPart.CFrame)
		local baseCF = realBaseCF
		local baseAxis = baseCF.lookVector
		local baseAxisPerp = baseAxis:Cross(V3new(0, 1, 0))
		local walkAxis = getWalkDirection(velocity)
		local walkAxisPerp = walkAxis:Cross(V3new(0, 1, 0))
		
		--
		mCurrentSpeed = max(-1, min(1, log(speed/16)/log(2)))
		--
		local leftStepping = mLeftLeg.StepCycle > 0
		local rightStepping = mRightLeg.StepCycle > 0
		--
				
		local function spline(t2, n, p)
			if n == 1 then
				return p[1]
			else
				local t1 = (1 - t2)
				for i = 1, n-1 do
					p[i] = t1*p[i] + t2*p[i+1]
				end
				return spline(t2, n-1, p)
			end
		end
			
		local function positionFootByCycle(leg, stepTarget)
			local baseVector = stepTarget - leg.Takeoff
			local sideVector = walkAxisPerp*leg.Side
			local baseLen = baseVector.magnitude
			local towardsSide = sideVector*(LEG_GAP/2)*0.3
			local towardsTop = V3new(0, 1.3*STRIDE_HEIGHT*(1 / leg.StepSpeedMod), 0)
			local topPoint = leg.Takeoff + baseVector * 1/2 + towardsTop + towardsSide
			local nextPoint = leg.Takeoff + baseVector * 0.9 + towardsTop + towardsSide
			--local a, b, c = leg.Takeoff, topPoint, stepTarget
			--local fb = leg.StepCycle
			--fb = fb^(_G.A or WALK_CYCLE_POWER)
			--local fa = 1-fb
			--
			--local footDesiredPos = fa*fa*a + 2*fa*fb*b + fb*fb*c
			local fb = leg.StepCycle^(_G.A or WALK_CYCLE_POWER)
			local footDesiredPos = spline(fb, 4, {leg.Takeoff, topPoint, nextPoint, stepTarget})
			--makeP(CFnew(footDesiredPos))
			if (footDesiredPos - leg.FootPosition).magnitude > dt*speed*FOOT_MAX_SPEED_FACTOR then
				local forcePos = (1 - leg.StepCycle) * leg.FootPosition + leg.StepCycle * footDesiredPos
				local movePos = leg.FootPosition + (footDesiredPos - leg.FootPosition).unit * dt*speed*FOOT_MAX_SPEED_FACTOR
				if (forcePos - footDesiredPos).magnitude < (movePos - footDesiredPos).magnitude then
					footDesiredPos = forcePos
				else
					footDesiredPos = movePos
				end
			end
			leg.FootPosition = footDesiredPos
			leg.LastStepTo = stepTarget
		end
		--
		local isCharacterWalking = isWalking(velocity)
		if isCharacterWalking then
			mStableStanding = false
		end
		--
		if isCharacterWalking then
			-- Get the desired ahead step
			local centeringMod = walkAxisPerp * (LEG_GAP/2) * 0.5
			local rightDesiredAheadStep = (baseCF * mRightLeg.OffsetModifier + getStrideForward()*walkAxis - mRightLeg.Side*centeringMod).p
			local leftDesiredAheadStep  = (baseCF *  mLeftLeg.OffsetModifier + getStrideForward()*walkAxis - mLeftLeg.Side*centeringMod).p
			local rightNorm, leftNorm;
			rightDesiredAheadStep, rightNorm = snapDown(rightDesiredAheadStep)
			leftDesiredAheadStep, leftNorm = snapDown(leftDesiredAheadStep)
			if not rightStepping or not mRightLeg.AheadStep or (rightDesiredAheadStep - mRightLeg.AheadStep).magnitude < dt*speed then
				mRightLeg.AheadStep = rightDesiredAheadStep
			else
				mRightLeg.AheadStep = mRightLeg.AheadStep + (rightDesiredAheadStep - mRightLeg.AheadStep).unit * dt*speed*2
			end
			mRightLeg.NormalHint = rightNorm
			if not leftStepping or not mLeftLeg.AheadStep or (leftDesiredAheadStep - mLeftLeg.AheadStep).magnitude < dt*speed then
				mLeftLeg.AheadStep = leftDesiredAheadStep
			else
				mLeftLeg.AheadStep = mLeftLeg.AheadStep + (leftDesiredAheadStep - mLeftLeg.AheadStep).unit * dt*speed*2
			end
			mLeftLeg.NormalHint = leftNorm
			
			local strideFactor = 0.9 - 0.3*max(0, mCurrentSpeed)
			local stepSpeed = speed / getStrideFull() * strideFactor
			
			-- Which legs are stepping?
			if not leftStepping and not rightStepping then
				-- Neither leg is stepping pick up the closer leg into the step
				if mAirborneFraction < 0.8 then -- don't pick up feet if we just landed
					if (mLeftLeg.FootPosition - mLeftLeg.AheadStep).magnitude < (mRightLeg.FootPosition - mRightLeg.AheadStep).magnitude then
						-- step p1
						local fracThere = min(0.9, max(0, (mLeftLeg.FootPosition - mLeftLeg.AheadStep).magnitude / getStrideFull()))
						mLeftLeg.StepSpeedMod = 1 / (1 - fracThere)
						mLeftLeg.StepCycle = dt
						mLeftLeg.Takeoff = mLeftLeg.FootPosition
					else
						-- step p2
						local fracThere = min(0.9, max(0, (mRightLeg.FootPosition - mRightLeg.AheadStep).magnitude / getStrideFull()))
						mRightLeg.StepSpeedMod = 1 / (1 - fracThere)
						mRightLeg.StepCycle = dt
						mRightLeg.Takeoff = mRightLeg.FootPosition
					end
				end
			elseif leftStepping and rightStepping then
				-- Both legs are stepping
				-- just step both legs
				-- The leg closer to |aheadStep| should step there, and the
				-- other leg should 
				for _, leg in pairs(mLegs) do
					leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed*leg.StepSpeedMod)
					positionFootByCycle(leg, leg.AheadStep)
					if leg.StepCycle == 1 then
						leg.StepCycle = 0
					end
				end
			else
				-- One leg is stepping.
				-- Step the one leg, and see if the other needs to enter a step
				for _, leg in pairs(mLegs) do
					if leg.StepCycle > 0 then
						-- Step this leg
						leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed*leg.StepSpeedMod)
						positionFootByCycle(leg, leg.AheadStep)
						
						-- Check if leg.Other needs to start a step
						if leg.StepCycle > strideFactor then
							leg.OtherLeg.StepSpeedMod = 1
							leg.OtherLeg.StepCycle = dt
							leg.OtherLeg.Takeoff = leg.OtherLeg.FootPosition
							positionFootByCycle(leg.OtherLeg, leg.AheadStep)
						end
						
						if leg.StepCycle == 1 then
							leg.StepCycle = 0
						end
						
						break
					end
				end
			end
		else
			local stepSpeed = 2			
			
			-- Not walking, we need to try to get to a suitable base position
			if leftStepping or rightStepping then
				for _, leg in pairs(mLegs) do
					if leg.StepCycle > 0 then
						leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed)
						local restingPos = (baseCF * leg.OffsetModifier).p
						local toVec = (leg.LastStepTo - restingPos)
						local targetPos;
						if toVec.magnitude > STRIDE_RESTING then
							targetPos = restingPos + (toVec.unit * STRIDE_RESTING)
						else
							targetPos = leg.LastStepTo
						end
						local norm;
						targetPos, norm = snapDown(targetPos)
						leg.AheadStep = targetPos
						leg.NormalHint = norm
						positionFootByCycle(leg, targetPos)
						if leg.StepCycle == 1 then
							leg.StepCycle = 0
						end
					else
						
					end
				end
			else
				fixFeetPositionsY()
			end
			
			-- Now, we stepped both legs. If both legs are resting now. See if 
			-- they are on roughly opposite offsets from where they should be.
			if mRightLeg.StepCycle == 0 and mLeftLeg.StepCycle == 0 then
				local rightResting = (baseCF * mRightLeg.OffsetModifier).p
				local leftResting = (baseCF * mLeftLeg.OffsetModifier).p
				local rightSep = mRightLeg.FootPosition - rightResting
				local leftSep = mLeftLeg.FootPosition - leftResting
				--
				local tooFar = abs(rightSep:Dot(baseAxis) - leftSep:Dot(baseAxis)) > 3
				local thetaBetweenFeet = acos(min(1, max(-1, rightSep.unit:Dot(leftSep.unit))))
				local distBetweenFeet = abs(rightSep.magnitude - leftSep.magnitude)
				--
				if rightSep:Dot(baseAxisPerp) > LEG_GAP/4 then
					mStableStanding = false
					mRightLeg.Takeoff = mRightLeg.FootPosition
					mRightLeg.StepCycle = dt
					--mRightLeg.LastStepTo = rightResting - baseAxisPerp*0.5
					local modLeftSep = leftSep.unit * 0.5
					if leftSep.magnitude == 0 then
						modLeftSep = -baseAxisPerp*0.5
					elseif leftSep:Dot(baseAxisPerp) > 0 then
						modLeftSep = (leftSep - 2*baseAxisPerp*leftSep:Dot(baseAxisPerp)).unit*0.5
					end
					mRightLeg.LastStepTo = rightResting + modLeftSep
					if (mRightLeg.LastStepTo - mRightLeg.Takeoff).magnitude < 0.5 then
						mRightLeg.StepCycle = 0
					end
					local fracThere = min(0.9, max(0, (mRightLeg.FootPosition - mRightLeg.LastStepTo).magnitude / getStrideFull()))
					mRightLeg.StepSpeedMod = 1 / (1 - fracThere)
				elseif leftSep:Dot(baseAxisPerp) < -LEG_GAP/4 then
					mStableStanding = false
					mLeftLeg.Takeoff = mLeftLeg.FootPosition
					mLeftLeg.StepCycle = dt
					--mLeftLeg.LastStepTo = leftResting + baseAxisPerp*0.5	
					local modRightSep = rightSep.unit * 0.5
					if rightSep.magnitude == 0 then
						modRightSep = baseAxisPerp*0.5
					elseif rightSep:Dot(baseAxisPerp) < 0 then
						modRightSep = (rightSep - 2*baseAxisPerp*rightSep:Dot(baseAxisPerp)).unit*0.5
					end
					mLeftLeg.LastStepTo = leftResting + modRightSep
					if (mRightLeg.LastStepTo - mRightLeg.Takeoff).magnitude < 0.5 then
						mRightLeg.StepCycle = 0
					end					
					local fracThere = min(0.9, max(0, (mLeftLeg.FootPosition - mLeftLeg.LastStepTo).magnitude / getStrideFull()))
					mLeftLeg.StepSpeedMod = 1 / (1 - fracThere)	
				elseif not mStableStanding and (thetaBetweenFeet < rad(150) or distBetweenFeet > 0.2 or tooFar) and mAirborneFraction < 0.5 then
					mStableStanding = true
					-- Step the foot further from the rest pos
					local furtherLeg, furtherResting, otherSep;
					if rightSep.magnitude > leftSep.magnitude then
						furtherLeg = mRightLeg
						furtherResting = rightResting
						otherSep = leftSep
					else
						furtherLeg = mLeftLeg
						furtherResting = leftResting
						otherSep = rightSep
					end
					--
					furtherLeg.StepCycle = dt
					furtherLeg.Takeoff = furtherLeg.FootPosition
					furtherLeg.StepSpeedMod = 1
					if tooFar then
						furtherLeg.LastStepTo = furtherResting - 0.5*otherSep
					else
						furtherLeg.LastStepTo = furtherResting - otherSep
					end
					if (furtherLeg.Takeoff - furtherLeg.LastStepTo).magnitude < 0.2 then
						furtherLeg.StepCycle = 0
					end
				end
			end
			fixFeetPositionsY()
		end
		
		local leftFootPosition,rightFootPosition = mLeftLeg.FootPosition,mRightLeg.FootPosition
		local footAngle = getBaseRotationY()
		local leftFootRotation = CFAngles(0,FOOT_ANGLE + footAngle,0)
		local rightFootRotation = CFAngles(0,-FOOT_ANGLE + footAngle,0)
		return CFnew(leftFootPosition) * leftFootRotation,CFnew(rightFootPosition) * rightFootRotation
	end
	
	function FootPlanterClass:OffsetFeet(Offset)
		overrideVelocityWithZero = true
		for _,leg in pairs(mLegs) do
			leg.FootPosition = leg.FootPosition + Offset
			leg.LastStepTo = leg.LastStepTo + Offset
			if leg.Takeoff then leg.Takeoff = leg.Takeoff + Offset end
			if leg.AheadStep then leg.AheadStep = leg.AheadStep + Offset end
		end
		overrideVelocityWithZero = true
	end
	
	return FootPlanterClass
end



return FootPlanter
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX94286E8B45B94595AB789AF49B935A1C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Head</string>
						<string name="ScriptGuid">{58B3DB69-428C-438F-8184-8CDE07DD92D1}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Stores information about the head of a character.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local Limb = require(script.Parent:WaitForChild("Limb"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local Head = {}
Head.__index = Head
setmetatable(Head, Limb)



--[[
Creates a head.
--]]
function Head.new(HeadPart: BasePart): any
    local self = Limb.new()
    self.Head = HeadPart
    return setmetatable(self, Head)
end

--[[
Returns the offset from the head to
the location of the eyes.
--]]
function Head:GetEyesOffset(): CFrame
    return (self:GetAttachmentCFrame(self.Head, "FaceFrontAttachment") :: CFrame) * CFrame.new(0, (self.Head :: BasePart).Size.Y / 4, 0)
end

--[[
Returns the head CFrame for the
given VR input in global world space.
--]]
function Head:GetHeadCFrame(VRHeadCFrame: CFrame): CFrame
    return VRHeadCFrame * self:GetEyesOffset():Inverse()
end

--[[
Returns the neck CFrame for the
given VR input in global world space.
--]]
function Head:GetNeckCFrame(VRHeadCFrame: CFrame, TargetAngle: number?): CFrame
    --Get the base neck CFrame and angles.
    local BaseNeckCFrame = (self:GetHeadCFrame(VRHeadCFrame) :: CFrame) * (self:GetAttachmentCFrame(self.Head, "NeckRigAttachment") :: CFrame)
    local BaseNeckLookVector = BaseNeckCFrame.LookVector
    local BaseNeckLook,BaseNeckTilt = math.atan2(BaseNeckLookVector.X, BaseNeckLookVector.Z) + math.pi, math.asin(BaseNeckLookVector.Y)

    --Clamp the new neck tilt.
    local NewNeckTilt = 0
    local MaxNeckTilt = Settings:GetSetting("Appearance.MaxNeckTilt") or math.rad(60)
    if BaseNeckTilt > MaxNeckTilt then
        NewNeckTilt = BaseNeckTilt - MaxNeckTilt
    elseif BaseNeckTilt < -MaxNeckTilt then
        NewNeckTilt = BaseNeckTilt + MaxNeckTilt
    end

    --Clamp the neck rotation if it is turning.
    if TargetAngle then
        --Determine the minimum angle difference.
        --Modulus is not used as it guarentees a positive answer, not the minimum answer, which can be negative.
        local RotationDifference = (BaseNeckLook - TargetAngle)
        while RotationDifference > math.pi do RotationDifference = RotationDifference - (2 * math.pi) end
        while RotationDifference < -math.pi do RotationDifference = RotationDifference + (2 * math.pi) end

        --Set the angle based on if it is over the limit or not.
        local MaxNeckSeatedRotation = Settings:GetSetting("Appearance.MaxNeckSeatedRotation") or math.rad(60)
        if RotationDifference > MaxNeckSeatedRotation then
            BaseNeckLook = RotationDifference - MaxNeckSeatedRotation
        elseif RotationDifference < -MaxNeckSeatedRotation then
            BaseNeckLook = RotationDifference + MaxNeckSeatedRotation
        else
            BaseNeckLook = 0
        end
    else
        local MaxNeckRotation = Settings:GetSetting("Appearance.MaxNeckRotation") or math.rad(35)
        if self.LastNeckRotationGlobal then
            --Determine the minimum angle difference.
            --Modulus is not used as it guarentees a positive answer, not the minimum answer, which can be negative.
            local RotationDifference = (BaseNeckLook - self.LastNeckRotationGlobal)
            while RotationDifference > math.pi do RotationDifference = RotationDifference - (2 * math.pi) end
            while RotationDifference < -math.pi do RotationDifference = RotationDifference + (2 * math.pi) end

            --Set the angle based on if it is over the limit or not.
            --Ignore if there is no previous stored rotation or if the rotation is "big" (like teleporting).
            if math.abs(RotationDifference) < 1.5 * MaxNeckRotation then
                if RotationDifference > MaxNeckRotation then
                    BaseNeckLook = BaseNeckLook - MaxNeckRotation
                elseif RotationDifference < -MaxNeckRotation then
                    BaseNeckLook = BaseNeckLook + MaxNeckRotation
                else
                    BaseNeckLook = self.LastNeckRotationGlobal
                end
            end
        end
    end
    self.LastNeckRotationGlobal = BaseNeckLook

    --Return the new neck CFrame.
    return CFrame.new(BaseNeckCFrame.Position) * CFrame.Angles(0, BaseNeckLook, 0) * CFrame.Angles(NewNeckTilt, 0, 0)
end



return Head]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9C72BDCDACA249CAA4879BC83CCD55C3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Limb</string>
						<string name="ScriptGuid">{7C026112-57EC-46CD-8073-92902DE681AA}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Base class for a limb.
--]]
--!strict

local Limb = {}
Limb.__index = Limb



--[[
Creates a limb object.
--]]
function Limb.new(): any
    return setmetatable({}, Limb)
end

--[[
Returns the CFrame of an attachment.
Returns an empty CFrame if the attachment
does not exist.
--]]
function Limb:GetAttachmentCFrame(Part: BasePart, AttachmentName: string): CFrame
    local Attachment = Part:FindFirstChild(AttachmentName)
    return Attachment and (Attachment :: Attachment).CFrame or CFrame.new()
end



return Limb]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX305D3080014E4C6AB1C436789C4954AE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Torso</string>
						<string name="ScriptGuid">{EE8CBD72-0AF3-4BF4-8126-81E680B85DA7}</string>
						<ProtectedString name="Source"><![CDATA[ --[[
TheNexusAvenger

Stores information about the torso of a character.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local Limb = require(script.Parent:WaitForChild("Limb"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local Torso = {}
Torso.__index = Torso
setmetatable(Torso, Limb)



--[[
Creates a torso.
--]]
function Torso.new(LowerTorso: BasePart, UpperTorso: BasePart): any
    local self = Limb.new()
    self.LowerTorso = LowerTorso
    self.UpperTorso = UpperTorso
    return setmetatable(self, Torso)
end

--[[
Returns the lower and upper torso CFrames
for the given neck CFrame in global world space.
--]]
function Torso:GetTorsoCFrames(NeckCFrame: CFrame): (CFrame, CFrame)
    --Determine the upper torso CFrame.
    local UpperTorsoCFrame = NeckCFrame * self:GetAttachmentCFrame(self.UpperTorso, "NeckRigAttachment"):Inverse()

    --Determine the center CFrame with bending.
    local MaxTorsoBend = Settings:GetSetting("Appearance.MaxTorsoBend") or math.rad(10)
    local NeckTilt = math.asin(NeckCFrame.LookVector.Y)
    local LowerTorsoAngle = math.sign(NeckTilt) * math.min(math.abs(NeckTilt), MaxTorsoBend)
    local TorsoCenterCFrame = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "WaistRigAttachment") * CFrame.Angles(-LowerTorsoAngle, 0, 0)

    --Return the lower and upper CFrames.
    return TorsoCenterCFrame * self:GetAttachmentCFrame(self.LowerTorso, "WaistRigAttachment"):Inverse(), UpperTorsoCFrame
end

--[[
Returns the CFrames of the joints for
the appendages.
--]]
function Torso:GetAppendageJointCFrames(LowerTorsoCFrame: CFrame, UpperTorsoCFrame: CFrame): {CFrame}
    return {
        RightShoulder = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "RightShoulderRigAttachment"),
        LeftShoulder = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "LeftShoulderRigAttachment"),
        LeftHip = LowerTorsoCFrame * self:GetAttachmentCFrame(self.LowerTorso, "LeftHipRigAttachment"),
        RightHip = LowerTorsoCFrame * self:GetAttachmentCFrame(self.LowerTorso, "RightHipRigAttachment"),
    }
end



return Torso]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX844DA85B5193465C8C0993F83DE1B53F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NexusVRCharacterModelClientLoader</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{36CC514F-805F-41B6-A19B-9AFB2EC4A6EF}</string>
					<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Loads Nexus VR Character Model on the client.
--]]
--!strict

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local NexusVRCharacterModel = ReplicatedStorage:WaitForChild("NexusVRCharacterModel") :: ModuleScript
local CameraService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")) :: any).GetInstance()
local CharacterService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CharacterService")) :: any).GetInstance()
local ControlService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")) :: any).GetInstance()
local DefaultCursorService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("DefaultCursorService")) :: any).GetInstance()
local Settings = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")) :: any).GetInstance()
local UpdateInputs = NexusVRCharacterModel:WaitForChild("UpdateInputs") :: RemoteEvent
local ReplicationReady = NexusVRCharacterModel:WaitForChild("ReplicationReady") :: RemoteEvent



--Load the settings.
Settings:SetDefaults(HttpService:JSONDecode((NexusVRCharacterModel:WaitForChild("Configuration") :: StringValue).Value))

--Connect replication for other players.
UpdateInputs.OnClientEvent:Connect(function(Player, HeadCFrame, LeftHandCFrame, RightHandCFrame)
    local Character = CharacterService:GetCharacter(Player)
    if Character then
        Character:UpdateFromInputs(HeadCFrame, LeftHandCFrame, RightHandCFrame)
    end
end)
ReplicationReady:FireServer()

--Allow checking if Nexus VR Character Model is loaded without being in VR.
local LoadedPrintStatementPrinted = false
UserInputService.InputBegan:Connect(function(Input)
    if not LoadedPrintStatementPrinted and Input.KeyCode == Enum.KeyCode.F9 and (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)) and Settings:GetSetting("Output.AllowClientToOutputLoadedMessage") ~= false then
        LoadedPrintStatementPrinted = true
        print("Nexus VR Character Model is loaded.")
    end
end)

--Wait for VR to be enabled.
while not UserInputService.VREnabled do
    UserInputService:GetPropertyChangedSignal("VREnabled"):Wait()
    warn("VR was detected later than when Nexus VR Character Model loaded. This may be a Roblox bug.")
end

--Disable the native VR controller models.
--Done in a pcall in case the SetCore is not registered or is removed.
task.spawn(function()
    for i = 1, 600 do
        local Worked = pcall(function()
            StarterGui:SetCore("VREnableControllerModels", false)
            DefaultCursorService:SetCursorState("Detect")
        end)
        if Worked then break end
        task.wait(0.1)
    end
end)

--Display a message if R6 is used.
local Character = Players.LocalPlayer.Character
while not Character do
    Character = Players.LocalPlayer.CharacterAdded:Wait()
end
if Character:WaitForChild("Humanoid").RigType == Enum.HumanoidRigType.R6 then
    local R6Message = (require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("R6Message")) :: any).new()
    R6Message:Open()
    return
end

--Set the initial controller and camera.
--Must happen before loading the settings in the main menu.
ControlService:SetActiveController(Settings:GetSetting("Movement.DefaultMovementMethod"))
CameraService:SetActiveCamera(Settings:GetSetting("Camera.DefaultCameraOption"))

--Load the menu.
local MainMenu = (require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("MainMenu")) :: any).GetInstance()
MainMenu:SetUpOpening()

--Load the backpack.
if Settings:GetSetting("Extra.NexusVRBackpackEnabled") ~= false then
    task.defer(function()
        local NexusVRBackpack = require(ReplicatedStorage:WaitForChild("NexusVRBackpack")) :: {Load: (any) -> ()}
        NexusVRBackpack:Load()
    end)
end

--Start updating the VR character.
RunService:BindToRenderStep("NexusVRCharacterModelUpdate", Enum.RenderPriority.Camera.Value - 1, function()
    ControlService:UpdateCharacter()
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXCB9FEBE09154484287A91A1C51C3E097">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">State</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX6B8F00AC88B64089933164C4D852D1E7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CameraService</string>
						<string name="ScriptGuid">{216DBBA5-4215-49AB-B4A3-088B8981E939}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Manages the local camera.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local DefaultCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("DefaultCamera"))
local ThirdPersonTrackCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("ThirdPersonTrackCamera"))

local CameraService = {}
CameraService.__index = CameraService
local StaticInstance = nil

export type CameraService = {
    new: () -> (CameraService),
    GetInstance: () -> (CameraService),

    ActiveCamera: string,
    RegisterCamera: (self: CameraService, Name: string, Camera: CameraInterface) -> (),
    SetActiveCamera: (self: CameraService, Name: string) -> (),
    UpdateCamera: (self: CameraService, HeadsetCFrameWorld: CFrame) -> (),
}

export type CameraInterface = {
    Enable: (self: CameraInterface) -> (),
    Disable: (self: CameraInterface) -> (),
    UpdateCamera: (self: CameraInterface, HeadsetCFrameWorld: CFrame) -> (),
}



--[[
Creates a camera service.
--]]
function CameraService.new(): CameraService
    --Create the object.
    local self = {
        RegisteredCameras = {},
    }
    setmetatable(self, CameraService)

    --Register the default controllers.
    self:RegisterCamera("Default", DefaultCamera.new())
    self:RegisterCamera("ThirdPersonTrack", ThirdPersonTrackCamera.new())

    --Return the object.
    return (self :: any) :: CameraService
end

--[[
Returns a singleton instance of the camera service.
--]]
function CameraService.GetInstance(): CameraService
    if not StaticInstance then
        StaticInstance = CameraService.new()
    end
    return StaticInstance
end

--[[
Registers a camera.
--]]
function CameraService:RegisterCamera(Name: string, Camera: CameraInterface): ()
    self.RegisteredCameras[Name] = Camera
end

--[[
Sets the active camera.
--]]
function CameraService:SetActiveCamera(Name: string): ()
    --Return if the camera didn't change.
    if self.ActiveCamera == Name then return end
    self.ActiveCamera = Name

    --Disable the current camera.
    if self.CurrentCamera then
        self.CurrentCamera:Disable()
    end

    --Enable the new camera.
    self.CurrentCamera = self.RegisteredCameras[Name]
    if self.CurrentCamera then
        self.CurrentCamera:Enable()
    elseif Name ~= nil then
        warn("Nexus VR Character Model camera \""..tostring(Name).."\" is not registered.")
    end
end

--[[
Updates the local camera.
--]]
function CameraService:UpdateCamera(HeadsetCFrameWorld: CFrame): ()
    if self.CurrentCamera then
        self.CurrentCamera:UpdateCamera(HeadsetCFrameWorld)
    end
end



return (CameraService :: any) :: CameraService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3C238BC942C14BE5A3B1F43B0E504FF1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CharacterService</string>
						<string name="ScriptGuid">{97284657-7DBE-4EB3-B38A-6D2716C48D78}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Manages VR characters.
--]]
--!strict

local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent
local Character = require(NexusVRCharacterModel:WaitForChild("Character"))

local CharacterService = {}
CharacterService.__index = CharacterService
local StaticInstance = nil

export type CharacterService = {
    new: () -> (CharacterService),
    GetInstance: () -> (CharacterService),

    GetCharacter: (self: CharacterService, Player: Player) -> (Character.Character?),
}



--[[
Creates a character service.
--]]
function CharacterService.new(): CharacterService
    --Create the object.
    local self = {
        Characters = {},
    }
    setmetatable(self, CharacterService)

    --Connect clearing players.
    Players.PlayerRemoving:Connect(function(Player)
        self.Characters[Player] = nil
    end)

    --Return the object.
    return (self :: any) :: CharacterService
end

--[[
Returns a singleton instance of the character service.
--]]
function CharacterService.GetInstance(): CharacterService
    if not StaticInstance then
        StaticInstance = CharacterService.new()
    end
    return StaticInstance
end

--[[
Returns the VR character for a player.
--]]
function CharacterService:GetCharacter(Player: Player): Character.Character?
    --Return if the character is nil.
    if not Player.Character then
        return nil
    end

    --Create the VR character if it isn't valid.
    if not self.Characters[Player] or self.Characters[Player].Character ~= Player.Character then
        self.Characters[Player] = {
            Character = Player.Character,
            VRCharacter = Character.new(Player.Character :: Model),
        }
    end

    --Return the stored character.
    return self.Characters[Player].VRCharacter
end



return (CharacterService :: any) :: CharacterService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX98504A78EA764BD8A14C9D3FA3A7F140">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ControlService</string>
						<string name="ScriptGuid">{8EF61559-B855-4236-80AF-D2FE66EE4653}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Manages controlling the local characters.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local BaseController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("BaseController"))
local TeleportController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("TeleportController"))
local SmoothLocomotionController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("SmoothLocomotionController"))

local ControlService = {}
ControlService.__index = ControlService
local StaticInstance = nil

export type ControlService = {
    new: () -> (ControlService),
    GetInstance: () -> (ControlService),

    ActiveController: string,
    RegisterController: (self: ControlService, Name: string, Controller: ControllerInterface) -> (),
    SetActiveController: (self: ControlService, Name: string) -> (),
    UpdateCharacter: (self: ControlService) -> (),
}

export type ControllerInterface = {
    Disable: (self: ControllerInterface) -> (),
    Enable: (self: ControllerInterface) -> (),
    UpdateCharacter: (self: ControllerInterface) -> (),
}



--[[
Creates a control service.
--]]
function ControlService.new(): ControlService
    --Create the object.
    local self = {
        RegisteredControllers = {},
    }
    setmetatable(self, ControlService)

    --Register the default controllers.
    self:RegisterController("None", BaseController.new())
    self:RegisterController("Teleport", TeleportController.new())
    self:RegisterController("SmoothLocomotion", SmoothLocomotionController.new())

    --Return the object.
    return (self :: any) :: ControlService
end

--[[
Returns a singleton instance of the character service.
--]]
function ControlService.GetInstance(): ControlService
    if not StaticInstance then
        StaticInstance = ControlService.new()
    end
    return StaticInstance
end

--[[
Registers a controller.
--]]
function ControlService:RegisterController(Name: string, Controller: any): ()
    self.RegisteredControllers[Name] = Controller
end

--[[
Sets the active controller.
--]]
function ControlService:SetActiveController(Name: string): ()
    --Return if the controller didn't change.
    if self.ActiveController == Name then return end
    self.ActiveController = Name

    --Disable the current controller.
    if self.CurrentController then
        self.CurrentController:Disable()
    end

    --Enable the new controller.
    self.CurrentController = self.RegisteredControllers[Name]
    if self.CurrentController then
        self.CurrentController:Enable()
    elseif Name ~= nil then
        warn("Nexus VR Character Model controller \""..tostring(Name).."\" is not registered.")
    end
end

--[[
Updates the local character.
--]]
function ControlService:UpdateCharacter()
    if self.CurrentController then
        self.CurrentController:UpdateCharacter()
    end
end



return (ControlService :: any) :: ControlService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX396B171B9FE943979E3012A3DF749DFE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DefaultCursorService</string>
						<string name="ScriptGuid">{E3537A9B-098D-4A94-A917-0AA617596581}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Manages toggling the default cursor.
Workaround for: https://github.com/TheNexusAvenger/Nexus-VR-Character-Model/issues/10
--]]
--!strict

local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")

local DefaultCursorService = {}
DefaultCursorService.__index = DefaultCursorService
local StaticInstance = nil

export type DefaultCursorService = {
    new: () -> (DefaultCursorService),
    GetInstance: () -> (DefaultCursorService),

    CursorOptionsList: {string},
    CurrentCursorState: string,
    SetCursorState: (self: DefaultCursorService, OptionName: string) -> (),
}



--[[
Creates a default cursor service.
--]]
function DefaultCursorService.new(): DefaultCursorService
    --Create the object.
    local self = {}
    setmetatable(self, DefaultCursorService)

    --Register the default values.
    self.CursorOptionsList = {"Detect", "Enabled", "Disabled"}
    self.CursorOptions = {
        Detect = function()
            --Enable the pointer.
            StarterGui:SetCore("VRLaserPointerMode", "Pointer")

            --Wait until the next frame to register the BindToRenderStep. Otherwise, the order is
            RunService.Stepped:Wait()

            --Enable the workaround for moving the pointer when the cursor isn't active.
            --It must be Last + 1 because the Core Script uses Last.
            RunService:BindToRenderStep("NexusVRCharacterModel_MoveCursorWorkaround", Enum.RenderPriority.Last.Value + 1, function()
                local Camera = Workspace.CurrentCamera
                local VRCoreEffectParts = Camera:FindFirstChild("VRCoreEffectParts")
                if VRCoreEffectParts then
                    local LaserPointerOrigin = VRCoreEffectParts:FindFirstChild("LaserPointerOrigin")
                    local Cursor = VRCoreEffectParts:FindFirstChild("Cursor")
                    if LaserPointerOrigin and Cursor then
                        local CursorSurfaceGui = Cursor:FindFirstChild("CursorSurfaceGui")
                        if CursorSurfaceGui and not CursorSurfaceGui.Enabled then
                            LaserPointerOrigin.CFrame = CFrame.new(0, math.huge, 0)
                        end
                    end
                end
            end)
        end,
        Enabled = function()
            StarterGui:SetCore("VRLaserPointerMode", "Pointer")
        end,
        Disabled = function()
            StarterGui:SetCore("VRLaserPointerMode", "Disabled")
        end,
    }
    self.CursorDisabledOptions = {
        Detect = function()
            RunService:UnbindFromRenderStep("NexusVRCharacterModel_MoveCursorWorkaround")
        end,
    }

    --Return the object.
    return (self :: any) :: DefaultCursorService
end

--[[
Returns a singleton instance of the character service.
--]]
function DefaultCursorService.GetInstance(): DefaultCursorService
    if not StaticInstance then
        StaticInstance = DefaultCursorService.new()
    end
    return StaticInstance
end

--[[
Sets the cursor state.
--]]
function DefaultCursorService:SetCursorState(OptionName: string): ()
    if self.CurrentCursorState == OptionName then return end
    if self.CurrentCursorState and self.CursorDisabledOptions[self.CurrentCursorState] then
        self.CursorDisabledOptions[self.CurrentCursorState]()
    end
    self.CurrentCursorState = OptionName
    task.spawn(self.CursorOptions[OptionName])
end



return DefaultCursorService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF6245EE0EE594B26BAC6DC2EA7849511">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RateLimiter</string>
						<string name="ScriptGuid">{652CEBD9-7210-4B20-AD38-3CB3482D0F31}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Performs rate limit checks on inputs.
--]]
--!strict

local Players = game:GetService("Players")

local RateLimiter = {}
RateLimiter.__index = RateLimiter

export type RateLimiter = {
    new: (RateLimit: number?, RefrestDuration: number?) -> (RateLimiter),

    RateLimitReached: (self: RateLimiter, Key: any) -> (boolean),
}



--[[
Creates a rate limiter.
The rate limit must be >=1.
--]]
function RateLimiter.new(RateLimit: number?, RefrestDuration: number?): RateLimiter
    --Create the object.
    local self = {
        RateLimit = RateLimit or 1,
        RefrestDuration = RefrestDuration or 1,
        UsedLimits = {}
    }
    setmetatable(self, RateLimiter)

    --Connect removing player keys.
    Players.PlayerRemoving:Connect(function(Player: Player)
        if self.UsedLimits[Player] then
            self.UsedLimits[Player] = nil
        end
    end)

    --Return the object.
    return (self :: any) :: RateLimiter
end

--[[
Returns if the rate limit was reached
for a given key.
--]]
function RateLimiter:RateLimitReached(Key: any): boolean
    --Add the key if it isn't defined.
    if not self.UsedLimits[Key] then
        self.UsedLimits[Key] = {
            StartTime = tick(),
            Count = 0,
        }
    end

    --Reset the key if the refresh time was reached.
    local StoredKey = self.UsedLimits[Key]
    local CurrentTime = tick()
    if CurrentTime > StoredKey.StartTime + self.RefrestDuration then
        StoredKey.StartTime = CurrentTime
        StoredKey.Count = 0
    end

    --Increment the counter and return if the limit was reached.
    StoredKey.Count = StoredKey.Count + 1
    return StoredKey.Count > self.RateLimit
end



return (RateLimiter :: any) :: RateLimiter]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX45489B4C7B22408782A46444E863A294">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Settings</string>
						<string name="ScriptGuid">{0F41E386-2660-4621-8AFC-766A99C85D3B}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Stores settings.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local Settings ={}
Settings.__index = Settings
local StaticInstance = nil

export type Settings ={
    new: () -> (Settings),
    GetInstance: () -> (Settings),

    GetSetting: (self: Settings, Setting: string) -> (any),
    SetSetting: (self: Settings, Setting: string, Value: any) -> (),
    SetDefaults: (self: Settings, Defaults: {[string]: any}) -> (),
    SetOverrides: (self: Settings, Overrides: {[string]: any}) -> (),
    GetSettingsChangedSignal: (self: Settings, Setting: string) -> (NexusEvent.NexusEvent<>),
    Destroy: (self: Settings) -> (),
}



--[[
Creates a settings object.
--]]
function Settings.new(): Settings
    return (setmetatable({
        Defaults = {},
        Overrides = {},
        SettingsChangeEvents = {},
        SettingsCache = {},
    }, Settings) :: any) :: Settings
end

--[[
Returns a singleton instance of settings.
--]]
function Settings.GetInstance(): Settings
    if not StaticInstance then
        StaticInstance = Settings.new()
    end
    return StaticInstance
end

--[[
Returns the value of a setting.
--]]
function Settings:GetSetting(Setting: string): any
    --Return a cached entry if one exists.
    if self.SettingsCache[Setting] ~= nil then
        return self.SettingsCache[Setting]
    end

    --Get the table containing the setting.
    local Defaults, Overrides = self.Defaults, self.Overrides
    local SplitSettingNames = string.split(Setting, ".")
    for i = 1, #SplitSettingNames - 1 do
        Defaults = Defaults[SplitSettingNames[i]] or {}
        Overrides = Overrides[SplitSettingNames[i]] or {}
    end

    --Return the value.
    local Value = Overrides[SplitSettingNames[#SplitSettingNames]]
    if Value == nil then
        Value = Defaults[SplitSettingNames[#SplitSettingNames]]
    end
    self.SettingsCache[Setting] = Value
    return Value
end

--[[
Sets the value of a setting.
--]]
function Settings:SetSetting(Setting: string, Value: any): ()
    --Set the setting.
    local Overrides = self.Overrides
    local SplitSettingNames = string.split(Setting,".")
    for i = 1, #SplitSettingNames - 1 do
        if not Overrides[SplitSettingNames[i]] then
            Overrides[SplitSettingNames[i]] = {}
        end
        Overrides = Overrides[SplitSettingNames[i]]
    end
    Overrides[SplitSettingNames[#SplitSettingNames]] = Value
    self.SettingsCache[Setting] = Value

    --Fire the changed signal.
    local Event = self.SettingsChangeEvents[string.lower(Setting)]
    if Event then
        Event:Fire()
    end
end

--[[
Sets all the defaults.
--]]
function Settings:SetDefaults(Defaults: {[string]: any}): ()
    --Set the defaults.
    self.Defaults = Defaults
    self.SettingsCache = {}

    --Fire all the event changes.
    for _, Event in self.SettingsChangeEvents do
        Event:Fire()
    end
end

--[[
Sets all the overrides.
--]]
function Settings:SetOverrides(Overrides: {[string]: any}): ()
    --Set the overrides.
    self.Overrides = Overrides
    self.SettingsCache = {}

    --Fire all the event changes.
    for _, Event in self.SettingsChangeEvents do
        Event:Fire()
    end
end

--[[
Returns a changed signal for a setting.
--]]
function Settings:GetSettingsChangedSignal(Overrides: string): NexusEvent.NexusEvent<>
    Overrides = string.lower(Overrides)

    --Create the event if none exists.
    if not self.SettingsChangeEvents[Overrides] then
        self.SettingsChangeEvents[Overrides] = NexusEvent.new()
    end

    --Return the event.
    return self.SettingsChangeEvents[Overrides]
end

--[[
Destroys the settings.
--]]
function Settings:Destroy(): ()
    --Disconnect the settings.
    for _,Event in self.SettingsChangeEvents do
        Event:Disconnect()
    end
    self.SettingsChangeEvents = {}
end



return Settings]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6F1EE27E3F1A4C189D4428B077EFAF82">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VRInputService</string>
						<string name="ScriptGuid">{8D9AD611-97F2-4E6E-9806-18B2D692280F}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Manages VR inputs. This normalizes the inputs from
the headsets as the Y position of the inputs is arbitrary,
meaning it can be the floor, eye level, or random.
--]]
--!strict

local THUMBSTICK_SAMPLES_TO_RESET = 5



local NexusVRCharacterModel = script.Parent.Parent
local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local VRInputService = {}
VRInputService.__index = VRInputService
local StaticInstance = nil

export type VRInputService = {
    new: (VRService: VRService?, UserInputService: UserInputService?) -> (VRInputService),
    GetInstance: () -> (VRInputService),

    Recentered: NexusEvent.NexusEvent<>,
    EyeLevelSet: NexusEvent.NexusEvent<>,
    GetVRInputs: (self: VRInputService) -> ({[Enum.UserCFrame]: CFrame}),
    Recenter: (self: VRInputService) -> (),
    SetEyeLevel: (self: VRInputService) -> (),
    GetThumbstickPosition: (self: VRInputService, Thumbsick: Enum.KeyCode) -> (Vector3),
}



--[[
Creates a settings object.
--]]
function VRInputService.new(VRService: VRService?, UserInputService: UserInputService?): VRInputService
    --Create the object.
    local self = {
        RecenterOffset = CFrame.new(),
    }
    setmetatable(self, VRInputService)

    --Store the services for testing.
    self.VRService = VRService or game:GetService("VRService")
    self.UserInputService = UserInputService or game:GetService("UserInputService")

    --Create the events.
    self.Recentered = NexusEvent.new()
    self.EyeLevelSet = NexusEvent.new()

    --Connect updating the thumbsticks.
    self.ThumbstickValues = {
        [Enum.KeyCode.Thumbstick1] = Vector3.new(),
        [Enum.KeyCode.Thumbstick2] = Vector3.new(),
    }
    self.PreviousThumbstickValues = {
        [Enum.KeyCode.Thumbstick1] = {},
        [Enum.KeyCode.Thumbstick2] = {},
    }
    self.CurrentThumbstickPointers = {
        [Enum.KeyCode.Thumbstick1] = 1,
        [Enum.KeyCode.Thumbstick2] = 1,
    }
    self.InputsDown = {
        [Enum.KeyCode.Thumbstick1] = false,
        [Enum.KeyCode.Thumbstick2] = false,
    }
    self.UserInputService.InputBegan:Connect(function(Input)
        if self.InputsDown[Input.KeyCode] ~= nil then
            self.InputsDown[Input.KeyCode] = true
        end
    end)
    self.UserInputService.InputEnded:Connect(function(Input)
        if self.InputsDown[Input.KeyCode] then
            self.InputsDown[Input.KeyCode] = false
        end
        if self.ThumbstickValues[Input.KeyCode] then
            self.ThumbstickValues[Input.KeyCode] = Vector3.new()
        end
    end)
    self.UserInputService.InputChanged:Connect(function(Input)
        if self.ThumbstickValues[Input.KeyCode] then
            self.ThumbstickValues[Input.KeyCode] = Input.Position
        end
    end)

    --Return the object.
    return (self :: any) :: VRInputService
end

--[[
Returns a singleton instance of the VR input service.
--]]
function VRInputService.GetInstance(): VRInputService
    if not StaticInstance then
        StaticInstance = VRInputService.new()
    end
    return StaticInstance
end

--[[
Returns the VR inputs to use. The inputs are normalized
so that 0 is the head height.
--]]
function VRInputService:GetVRInputs(): {[Enum.UserCFrame]: CFrame}
    --Get the head input.
    local VRInputs = {
        [Enum.UserCFrame.Head] = self.VRService:GetUserCFrame(Enum.UserCFrame.Head),
    } :: {[Enum.UserCFrame]: CFrame}

    --Get the hand inputs.
    if self.VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand) then
        VRInputs[Enum.UserCFrame.LeftHand] = self.VRService:GetUserCFrame(Enum.UserCFrame.LeftHand)
    else
        VRInputs[Enum.UserCFrame.LeftHand] = VRInputs[Enum.UserCFrame.Head] * CFrame.new(-1, -2.5, 0.5)
    end
    if self.VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) then
        VRInputs[Enum.UserCFrame.RightHand] = self.VRService:GetUserCFrame(Enum.UserCFrame.RightHand)
    else
        VRInputs[Enum.UserCFrame.RightHand] = VRInputs[Enum.UserCFrame.Head] * CFrame.new(1, -2.5, 0.5)
    end

    --Determine the height offset.
    local HeightOffset = 0
    if self.ManualNormalHeadLevel then
        --Adjust to normalize the height around the set value.
        HeightOffset = -self.ManualNormalHeadLevel
    else
        --Adjust to normalize the height around the highest value.
        --The head CFrame is moved back 0.5 studs for when the headset suddenly goes up (like putting on and taking off).
        local CurrentVRHeadHeight = (VRInputs[Enum.UserCFrame.Head] * CFrame.new(0, 0, 0.5)).Y
        if not self.HighestHeadHeight or CurrentVRHeadHeight > self.HighestHeadHeight then
            self.HighestHeadHeight = CurrentVRHeadHeight
        end
        HeightOffset = -self.HighestHeadHeight
    end

    --Normalize the CFrame heights.
    --A list of enums is used instead of VRInputs because modifying a table stops pairs().
    for _, InputEnum in {Enum.UserCFrame.Head, Enum.UserCFrame.LeftHand, Enum.UserCFrame.RightHand} do
        VRInputs[InputEnum] = CFrame.new(0, HeightOffset, 0) * self.RecenterOffset * VRInputs[InputEnum]
    end

    --Return the CFrames.
    return VRInputs
end

--[[
Recenters the service.
Does not alter the Y axis.
--]]
function VRInputService:Recenter(): ()
    local HeadCFrame = self.VRService:GetUserCFrame(Enum.UserCFrame.Head)
    self.RecenterOffset = CFrame.Angles(0, -math.atan2(-HeadCFrame.LookVector.X, -HeadCFrame.LookVector.Z), 0) * CFrame.new(-HeadCFrame.X, 0, -HeadCFrame.Z)
    self.Recentered:Fire()
end

--[[
Sets the eye level.
--]]
function VRInputService:SetEyeLevel(): ()
    self.ManualNormalHeadLevel = self.VRService:GetUserCFrame(Enum.UserCFrame.Head).Y
    self.EyeLevelSet:Fire()
end

--[[
Returns the current value for a thumbstick.
--]]
function VRInputService:GetThumbstickPosition(Thumbsick: Enum.KeyCode): Vector3
    --Return if the value isn't supported.
    if not self.ThumbstickValues[Thumbsick] then
        return Vector3.zero
    end

    --Store the polled value.
    self.PreviousThumbstickValues[Thumbsick][self.CurrentThumbstickPointers[Thumbsick]] = self.ThumbstickValues[Thumbsick]
    self.CurrentThumbstickPointers[Thumbsick] = (self.CurrentThumbstickPointers[Thumbsick] :: number % THUMBSTICK_SAMPLES_TO_RESET) + 1

    --Determine if the polled values are exactly the same.
    --Closeness is not used as the thumbstick being held in place will register as slightly different values.
    --This happens if the trigger is released (such as a touchpad, which may not automatically reset).
    local ValuesSame = true
    local InitialValue = self.PreviousThumbstickValues[Thumbsick][1]
    for i = 2, THUMBSTICK_SAMPLES_TO_RESET do
        if self.PreviousThumbstickValues[Thumbsick][i] ~= InitialValue then
            ValuesSame = false
            break
        end
    end

    --Return either the stored value or the empty vector if the last polled samples are the same.
    if ValuesSame and not self.InputsDown[Thumbsick] then
        return Vector3.zero
    else
        return self.ThumbstickValues[Thumbsick]
    end
end



return (VRInputService :: any) :: VRInputService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX9E43A64C8E3F458FB6B01CAEDA4358AC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX6D743545C3404C4D9C45D7AE31F2F904">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MainMenu</string>
						<string name="ScriptGuid">{7333F812-50FC-4BEB-9391-1867CBE51444}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Main menu for Nexus VR Character Model.
--]]
--!strict

local MENU_OPEN_TIME_REQUIREMENT = 1
local MENU_OPEN_TIME = 0.25



local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local NexusVRCharacterModel = script.Parent.Parent
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()
local ApiBaseView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("ApiBaseView"))
local ChatView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("ChatView"))
local SettingsView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("SettingsView"))
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")
local NexusVRCore = require(ReplicatedStorage:WaitForChild("NexusVRCore")) :: any
local ScreenGui = NexusVRCore:GetResource("Container.ScreenGui")

local MainMenu = {}
MainMenu.__index = MainMenu
local StaticInstance = nil



--[[
Creates the main menu.
--]]
function MainMenu.new(): any
    local self = {}
    setmetatable(self, MainMenu)

    --Set up the ScreenGui.
    local MainMenuScreenGui = ScreenGui.new()
    MainMenuScreenGui.ResetOnSpawn = false
    MainMenuScreenGui.Enabled = false
    MainMenuScreenGui.CanvasSize = Vector2.new(500, 600)
    MainMenuScreenGui.FieldOfView = 0
    MainMenuScreenGui.Easing = 0.25
    self.ScreenGui = MainMenuScreenGui

    --Create the parent frame, display text, and toggle buttons.
    local ViewAdornFrame = Instance.new("Frame")
    ViewAdornFrame.BackgroundTransparency = 1
    ViewAdornFrame.Size = UDim2.new(0, 500, 0, 500)
    ViewAdornFrame.Parent = MainMenuScreenGui:GetContainer()
    self.ViewAdornFrame = ViewAdornFrame

    local LeftButton, LeftText = TextButtonFactory:Create()
    LeftButton.Size = UDim2.new(0, 80, 0, 80)
    LeftButton.Position = UDim2.new(0, 10, 0, 510)
    LeftButton.Parent = MainMenuScreenGui:GetContainer()
    LeftText.Text = "<"
    self.LeftButton = LeftButton

    local RightButton, RightText = TextButtonFactory:Create()
    RightButton.Size = UDim2.new(0, 80, 0, 80)
    RightButton.Position = UDim2.new(0, 410, 0, 510)
    RightButton.Parent = MainMenuScreenGui:GetContainer()
    RightText.Text = ">"
    self.RightButton = RightButton

    local ViewTextLabel = Instance.new("TextLabel")
    ViewTextLabel.BackgroundTransparency = 1
    ViewTextLabel.Size = UDim2.new(0, 300, 0, 60)
    ViewTextLabel.Position = UDim2.new(0, 100, 0, 520)
    ViewTextLabel.Font = Enum.Font.SourceSansBold
    ViewTextLabel.TextScaled = true
    ViewTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ViewTextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    ViewTextLabel.TextStrokeTransparency = 0
    ViewTextLabel.Parent = MainMenuScreenGui:GetContainer()
    self.ViewTextLabel = ViewTextLabel

    --Set up the default views.
    self.CurrentView = 1
    self.Views = {}
    (SettingsView :: any).new(self:CreateView("Settings"));
    (ChatView :: any).new(self:CreateView("Chat"))
    self:UpdateVisibleView()

    --Connect changing views.
    local DB = true
    LeftButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false

        --De-increment the current view.
        self.CurrentView = self.CurrentView - 1
        if self.CurrentView == 0 then
            self.CurrentView = #self.Views
        end

        --Update the views.
        self:UpdateVisibleView()
        task.wait()
        DB = true
    end)
    RightButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false

        --Increment the current view.
        self.CurrentView = self.CurrentView + 1
        if self.CurrentView > #self.Views then
            self.CurrentView = 1
        end

        --Update the views.
        self:UpdateVisibleView()
        task.wait()
        DB = true
    end)

    --Parent the menu.
    MainMenuScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return self
end

--[[
Returns a singleton instance of the character service.
--]]
function MainMenu.GetInstance(): any
    if not StaticInstance then
        StaticInstance = MainMenu.new()
    end
    return StaticInstance
end

--[[
Sets up opening based on the controllers
being rotated upwards.
--]]
function MainMenu:SetUpOpening(): ()
    --Create the animation parts.
    local LeftAdornPart = Instance.new("Part")
    LeftAdornPart.Transparency = 1
    LeftAdornPart.Size = Vector3.new()
    LeftAdornPart.Anchored = true
    LeftAdornPart.CanCollide = false
    LeftAdornPart.CanQuery = false
    LeftAdornPart.Parent = Workspace.CurrentCamera

    local LeftAdorn = Instance.new("BoxHandleAdornment")
    LeftAdorn.Color3 = Color3.fromRGB(0, 170, 255)
    LeftAdorn.AlwaysOnTop = true
    LeftAdorn.ZIndex = 0
    LeftAdorn.Adornee = LeftAdornPart
    LeftAdorn.Parent = LeftAdornPart

    local RightAdornPart = Instance.new("Part")
    RightAdornPart.Transparency = 1
    RightAdornPart.Size = Vector3.new()
    RightAdornPart.Anchored = true
    RightAdornPart.CanCollide = false
    RightAdornPart.CanQuery = false
    RightAdornPart.Parent = Workspace.CurrentCamera

    local RightAdorn = Instance.new("BoxHandleAdornment")
    RightAdorn.Color3 = Color3.fromRGB(0, 170 , 255)
    RightAdorn.AlwaysOnTop = true
    RightAdorn.ZIndex = 0
    RightAdorn.Adornee = RightAdornPart
    RightAdorn.Parent = RightAdornPart

    local LeftMenuToggleHintAdornPart = Instance.new("Part")
    LeftMenuToggleHintAdornPart.Transparency = 1
    LeftMenuToggleHintAdornPart.Size = Vector3.new(1,1,0)
    LeftMenuToggleHintAdornPart.Anchored = true
    LeftMenuToggleHintAdornPart.CanCollide = false
    LeftMenuToggleHintAdornPart.CanQuery = false
    LeftMenuToggleHintAdornPart.Parent = Workspace.CurrentCamera

    local RightMenuToggleHintAdornPart = Instance.new("Part")
    RightMenuToggleHintAdornPart.Transparency = 1
    RightMenuToggleHintAdornPart.Size = Vector3.new(1,1,0)
    RightMenuToggleHintAdornPart.Anchored = true
    RightMenuToggleHintAdornPart.CanCollide = false
    RightMenuToggleHintAdornPart.CanQuery = false
    RightMenuToggleHintAdornPart.Parent = Workspace.CurrentCamera

    local LeftMenuToggleHintGuiFront = Instance.new("SurfaceGui")
    LeftMenuToggleHintGuiFront.Active = false
    LeftMenuToggleHintGuiFront.Face = Enum.NormalId.Front
    LeftMenuToggleHintGuiFront.CanvasSize = Vector2.new(500,500)
    LeftMenuToggleHintGuiFront.LightInfluence = 0
    LeftMenuToggleHintGuiFront.AlwaysOnTop = true
    LeftMenuToggleHintGuiFront.Adornee = LeftMenuToggleHintAdornPart
    LeftMenuToggleHintGuiFront.Parent = LeftMenuToggleHintAdornPart

    local LeftMenuToggleHintFrontArrow = Instance.new("ImageLabel")
    LeftMenuToggleHintFrontArrow.ImageTransparency = 1
    LeftMenuToggleHintFrontArrow.BackgroundTransparency = 1
    LeftMenuToggleHintFrontArrow.Rotation = 180
    LeftMenuToggleHintFrontArrow.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintFrontArrow.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintFrontArrow.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintFrontArrow.ImageRectOffset = Vector2.new(0,0)
    LeftMenuToggleHintFrontArrow.Parent = LeftMenuToggleHintGuiFront

    local LeftMenuToggleHintFrontText = Instance.new("ImageLabel")
    LeftMenuToggleHintFrontText.ImageTransparency = 1
    LeftMenuToggleHintFrontText.BackgroundTransparency = 1
    LeftMenuToggleHintFrontText.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintFrontText.ZIndex = 2
    LeftMenuToggleHintFrontText.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintFrontText.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintFrontText.ImageRectOffset = Vector2.new(0,512)
    LeftMenuToggleHintFrontText.Parent = LeftMenuToggleHintGuiFront

    local LeftMenuToggleHintGuiBack = Instance.new("SurfaceGui")
    LeftMenuToggleHintGuiBack.Active = false
    LeftMenuToggleHintGuiBack.Face = Enum.NormalId.Back
    LeftMenuToggleHintGuiBack.CanvasSize = Vector2.new(500,500)
    LeftMenuToggleHintGuiBack.LightInfluence = 0
    LeftMenuToggleHintGuiBack.AlwaysOnTop = true
    LeftMenuToggleHintGuiBack.Adornee = LeftMenuToggleHintAdornPart
    LeftMenuToggleHintGuiBack.Parent = LeftMenuToggleHintAdornPart

    local LeftMenuToggleHintBackArrow = Instance.new("ImageLabel")
    LeftMenuToggleHintBackArrow.ImageTransparency = 1
    LeftMenuToggleHintBackArrow.BackgroundTransparency = 1
    LeftMenuToggleHintBackArrow.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintBackArrow.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintBackArrow.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintBackArrow.ImageRectOffset = Vector2.new(512,0)
    LeftMenuToggleHintBackArrow.Parent = LeftMenuToggleHintGuiBack

    local LeftMenuToggleHintBackText = Instance.new("ImageLabel")
    LeftMenuToggleHintBackText.ImageTransparency = 1
    LeftMenuToggleHintBackText.BackgroundTransparency = 1
    LeftMenuToggleHintBackText.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintBackText.ZIndex = 2
    LeftMenuToggleHintBackText.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintBackText.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintBackText.ImageRectOffset = Vector2.new(0,512)
    LeftMenuToggleHintBackText.Parent = LeftMenuToggleHintGuiBack

    local RightMenuToggleHintGuiFront = Instance.new("SurfaceGui")
    RightMenuToggleHintGuiFront.Active = false
    RightMenuToggleHintGuiFront.Face = Enum.NormalId.Front
    RightMenuToggleHintGuiFront.CanvasSize = Vector2.new(500,500)
    RightMenuToggleHintGuiFront.LightInfluence = 0
    RightMenuToggleHintGuiFront.AlwaysOnTop = true
    RightMenuToggleHintGuiFront.Adornee = RightMenuToggleHintAdornPart
    RightMenuToggleHintGuiFront.Parent = RightMenuToggleHintAdornPart

    local RightMenuToggleHintFrontArrow = Instance.new("ImageLabel")
    RightMenuToggleHintFrontArrow.ImageTransparency = 1
    RightMenuToggleHintFrontArrow.BackgroundTransparency = 1
    RightMenuToggleHintFrontArrow.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintFrontArrow.Image = "rbxassetid://6537091378"
    RightMenuToggleHintFrontArrow.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintFrontArrow.ImageRectOffset = Vector2.new(512,0)
    RightMenuToggleHintFrontArrow.Parent = RightMenuToggleHintGuiFront

    local RightMenuToggleHintFrontText = Instance.new("ImageLabel")
    RightMenuToggleHintFrontText.ImageTransparency = 1
    RightMenuToggleHintFrontText.BackgroundTransparency = 1
    RightMenuToggleHintFrontText.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintFrontText.ZIndex = 2
    RightMenuToggleHintFrontText.Image = "rbxassetid://6537091378"
    RightMenuToggleHintFrontText.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintFrontText.ImageRectOffset = Vector2.new(0,512)
    RightMenuToggleHintFrontText.Parent = RightMenuToggleHintGuiFront

    local RightMenuToggleHintGuiBack = Instance.new("SurfaceGui")
    RightMenuToggleHintGuiBack.Active = false
    RightMenuToggleHintGuiBack.Face = Enum.NormalId.Back
    RightMenuToggleHintGuiBack.CanvasSize = Vector2.new(500,500)
    RightMenuToggleHintGuiBack.LightInfluence = 0
    RightMenuToggleHintGuiBack.AlwaysOnTop = true
    RightMenuToggleHintGuiBack.Adornee = RightMenuToggleHintAdornPart
    RightMenuToggleHintGuiBack.Parent = RightMenuToggleHintAdornPart

    local RightMenuToggleHintBackArrow = Instance.new("ImageLabel")
    RightMenuToggleHintBackArrow.ImageTransparency = 1
    RightMenuToggleHintBackArrow.BackgroundTransparency = 1
    RightMenuToggleHintBackArrow.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintBackArrow.Image = "rbxassetid://6537091378"
    RightMenuToggleHintBackArrow.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintBackArrow.ImageRectOffset = Vector2.new(0,0)
    RightMenuToggleHintBackArrow.Parent = RightMenuToggleHintGuiBack

    local RightMenuToggleHintBackText = Instance.new("ImageLabel")
    RightMenuToggleHintBackText.BackgroundTransparency = 1
    RightMenuToggleHintBackText.Rotation = 180
    RightMenuToggleHintBackText.ImageTransparency = 1
    RightMenuToggleHintBackText.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintBackText.ZIndex = 2
    RightMenuToggleHintBackText.Image = "rbxassetid://6537091378"
    RightMenuToggleHintBackText.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintBackText.ImageRectOffset = Vector2.new(0,512)
    RightMenuToggleHintBackText.Parent = RightMenuToggleHintGuiBack

    --Connect hiding the hints when the setting changes.
    Settings:GetSettingsChangedSignal("Menu.MenuToggleGestureActive"):Connect(function()
        --Determine if the gesture is active.
        local MenuToggleGestureActive = Settings:GetSetting("Menu.MenuToggleGestureActive")
        if MenuToggleGestureActive == nil then
            MenuToggleGestureActive = true
        end

        --Update the visibility of the hints.
        LeftMenuToggleHintGuiFront.Enabled = MenuToggleGestureActive
        LeftMenuToggleHintGuiBack.Enabled = MenuToggleGestureActive
        RightMenuToggleHintGuiFront.Enabled = MenuToggleGestureActive
        RightMenuToggleHintGuiBack.Enabled = MenuToggleGestureActive
    end)


    --Start checking for the controllers to be upside down.
    --Done in a task since this function is non-yielding.
    local BothControllersUpStartTime
    local MenuToggleReached = false
    task.spawn(function()
        while true do
            --Determine if the gesture is active.
            local MenuToggleGestureActive = Settings:GetSetting("Menu.MenuToggleGestureActive")
            if MenuToggleGestureActive == nil then
                MenuToggleGestureActive = true
            end

            --Get the inputs and determine if the hands are both upside down and pointing forward.
            local VRInputs = VRInputService:GetVRInputs()
            local LeftHandCFrameRelative, RightHandCFrameRelative = VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[Enum.UserCFrame.LeftHand], VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[Enum.UserCFrame.RightHand]
            local LeftHandFacingUp, RightHandFacingUp = LeftHandCFrameRelative.UpVector.Y < 0, RightHandCFrameRelative.UpVector.Y < 0
            local LeftHandFacingForward, RightHandFacingForward = LeftHandCFrameRelative.LookVector.Z < 0, RightHandCFrameRelative.LookVector.Z < 0
            local LeftHandUp, RightHandUp = LeftHandFacingUp and LeftHandFacingForward, RightHandFacingUp and RightHandFacingForward
            local BothHandsUp = MenuToggleGestureActive and LeftHandUp and RightHandUp
            if BothHandsUp then
                BothControllersUpStartTime = BothControllersUpStartTime or tick()
            else
                BothControllersUpStartTime = nil :: any
                MenuToggleReached = false
            end

            --Update the adorn part CFrames.
            local CameraCenterCFrame = Workspace.CurrentCamera:GetRenderCFrame() * VRInputs[Enum.UserCFrame.Head]:Inverse()
            LeftAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.LeftHand] * CFrame.new(0, -0.25, 0.25)
            RightAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.RightHand] * CFrame.new(0, -0.25, 0.25)
            LeftMenuToggleHintAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.LeftHand]
            RightMenuToggleHintAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.RightHand]

            --Update the progress bars.
            if BothControllersUpStartTime and not MenuToggleReached then
                local DeltaTimePercent = (tick() - BothControllersUpStartTime) / MENU_OPEN_TIME_REQUIREMENT
                LeftAdorn.Size = Vector3.new(0.1, 0, 0.25 * DeltaTimePercent)
                RightAdorn.Size = Vector3.new(0.1, 0, 0.25 * DeltaTimePercent)
                LeftAdorn.Visible = true
                RightAdorn.Visible = true

                --Toggle the menu if the time threshold was reached.
                if DeltaTimePercent >= 1 then
                    MenuToggleReached = true
                    task.spawn(function()
                        self:Toggle()
                    end)
                end
            else
                LeftAdorn.Visible = false
                RightAdorn.Visible = false
            end

            --[[
            Updates the given hint parts.
            --]]
            local function UpdateHintParts(Visible,Part,FrontArrow,BackArrow,FrontText,BackText)
                local TweenData = TweenInfo.new(0.25)
                TweenService:Create(Part,TweenData,{
                    Size = Visible and Vector3.new(1, 1, 0) or Vector3.new(1.5, 1.5, 0)
                }):Play()
                TweenService:Create(FrontArrow,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(BackArrow,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(FrontText,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(BackText,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
            end

            --Update the hints.
            local LeftHandHintVisible, RightHandHintVisible = self.ScreenGui.Enabled and not LeftHandUp, self.ScreenGui.Enabled and not RightHandUp
            if self.LeftHandHintVisible ~= LeftHandHintVisible then
                self.LeftHandHintVisible = LeftHandHintVisible
                UpdateHintParts(LeftHandHintVisible, LeftMenuToggleHintAdornPart, LeftMenuToggleHintFrontArrow, LeftMenuToggleHintBackArrow, LeftMenuToggleHintFrontText, LeftMenuToggleHintBackText)
            end
            if self.RightHandHintVisible ~= RightHandHintVisible then
                self.RightHandHintVisible = RightHandHintVisible
                UpdateHintParts(RightHandHintVisible, RightMenuToggleHintAdornPart, RightMenuToggleHintFrontArrow, RightMenuToggleHintBackArrow, RightMenuToggleHintFrontText, RightMenuToggleHintBackText)
            end
            local Rotation = (tick() * 10) % 360
            LeftMenuToggleHintFrontArrow.Rotation = Rotation
            LeftMenuToggleHintBackArrow.Rotation = -Rotation
            RightMenuToggleHintFrontArrow.Rotation = -Rotation
            RightMenuToggleHintBackArrow.Rotation = Rotation

            --Wait to poll again.
            RunService.RenderStepped:Wait()
        end
    end)
end

--[[
Toggles the menu being open.
--]]
function MainMenu:Toggle(): ()
    --Determine the start and end values.
    local StartFieldOfView, EndFieldOfView = (self.ScreenGui.Enabled and math.rad(40) or 0), (self.ScreenGui.Enabled and 0 or math.rad(40))

    --Show the menu if it isn't visible.
    if not self.ScreenGui.Enabled then
        self.ScreenGui.Enabled = true
    end

    --Tween the field of view.
    local StartTime = tick()
    while tick() - StartTime < MENU_OPEN_TIME do
        local Delta = (tick() - StartTime) / MENU_OPEN_TIME
        Delta = (math.sin((Delta - 0.5) * math.pi) / 2) + 0.5
        self.ScreenGui.FieldOfView = StartFieldOfView + ((EndFieldOfView - StartFieldOfView) * Delta)
        RunService.RenderStepped:Wait()
    end

    --Hide thhe menu if it is closed.
    if EndFieldOfView == 0 then
        self.ScreenGui.Enabled = false
    end
end

--[[
Registers a view.
--]]
function MainMenu:RegisterView(ViewName: string, ViewInstance: any): ()
    warn("MainMenu::RegisterView is deprecated and may be removed in the future. Use MainMenu::CreateView instead.")

    --Set up the view instance.
    ViewInstance.Visible = false
    ViewInstance.Name = ViewName
    ViewInstance.Parent = self.ViewAdornFrame

    --Store the view.
    table.insert(self.Views, ViewInstance)
end

--[[
Creates a menu view.
--]]
function MainMenu:CreateView(InitialViewName: string): any
    --Create and store the view.
    local View = ApiBaseView.new(InitialViewName)
    View.Frame.Parent = (self :: any).ViewAdornFrame
    table.insert(self.Views, View)

    --Connect the events.
    View:GetPropertyChangedSignal("Name"):Connect(function()
        self:UpdateVisibleView()
    end)
    View.Destroyed:Connect(function()
        for i = 1, #self.Views do
            if self.Views[i] == View then
                table.remove(self.Views, i)
                if self.CurrentView > i then
                    self.CurrentView += -1
                end
                break
            end
        end
        self:UpdateVisibleView()
    end)
    return View
end

--[[
Updates the visible view.
--]]
function MainMenu:UpdateVisibleView(): ()
    --Update the button visibility.
    self.LeftButton.Visible = (#self.Views > 1)
    self.RightButton.Visible = (#self.Views > 1)

    --Update the display text.
    self.ViewTextLabel.Text = self.Views[self.CurrentView].Name

    --Update the view visibilites.
    for i, View in self.Views do
        View.Visible = (i == self.CurrentView)
    end
end



return MainMenu]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8BA34C6462CB44EFB984703905E3A9AF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">R6Message</string>
						<string name="ScriptGuid">{41313555-BF43-49B3-B525-C62D4809AB31}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Displays a message if R6 is used.
--]]
--!strict

local MESSAGE_OPEN_TIME = 0.25



local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local NexusVRCharacterModel = script.Parent.Parent
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")
local NexusVRCore = require(ReplicatedStorage:WaitForChild("NexusVRCore")) :: any
local ScreenGui = NexusVRCore:GetResource("Container.ScreenGui")

local R6Message = {}
R6Message.__index = R6Message



--[[
Creates the R6 message.
--]]
function R6Message.new(): any
    local self = {}
    setmetatable(self, R6Message)

    --Set up the ScreenGui.
    local MessageScreenGui = ScreenGui.new()
    MessageScreenGui.ResetOnSpawn = false
    MessageScreenGui.Enabled = false
    MessageScreenGui.CanvasSize = Vector2.new(500, 500)
    MessageScreenGui.FieldOfView = 0
    MessageScreenGui.Easing = 0.25
    self.ScreenGui = MessageScreenGui

    --Create the logo and message.
    local Logo = Instance.new("ImageLabel")
    Logo.BackgroundTransparency = 1
    Logo.Size = UDim2.new(0.4, 0, 0.4, 0)
    Logo.Position = UDim2.new(0.3, 0, -0.1, 0)
    Logo.Image = "http://www.roblox.com/asset/?id=1499731139"
    Logo.Parent = MessageScreenGui:GetContainer()

    local UpperText = Instance.new("TextLabel")
    UpperText.BackgroundTransparency = 1
    UpperText.Size = UDim2.new(0.8, 0, 0.1, 0)
    UpperText.Position = UDim2.new(0.1, 0, 0.25, 0)
    UpperText.Font = Enum.Font.SourceSansBold
    UpperText.Text = "R6 Not Supported"
    UpperText.TextScaled = true
    UpperText.TextColor3 = Color3.fromRGB(255, 255, 255)
    UpperText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    UpperText.TextStrokeTransparency = 0
    UpperText.Parent = MessageScreenGui:GetContainer()

    local LowerText = Instance.new("TextLabel")
    LowerText.BackgroundTransparency = 1
    LowerText.Size = UDim2.new(0.8, 0, 0.25, 0)
    LowerText.Position = UDim2.new(0.1, 0, 0.4, 0)
    LowerText.Font = Enum.Font.SourceSansBold
    LowerText.Text = "Nexus VR Character Model does not support using R6. Use R15 instead."
    LowerText.TextScaled = true
    LowerText.TextColor3 = Color3.fromRGB(255, 255, 255)
    LowerText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    LowerText.TextStrokeTransparency = 0
    LowerText.Parent = MessageScreenGui:GetContainer()

    --Create and connect the close button.
    local CloseButton, CloseText = TextButtonFactory:Create()
    CloseButton.Size = UDim2.new(0.3, 0, 0.1, 0)
    CloseButton.Position = UDim2.new(0.35, 0, 0.7, 0)
    CloseButton.Parent = MessageScreenGui:GetContainer()
    CloseText.Text = "Ok"

    CloseButton.MouseButton1Down:Connect(function()
        self:SetOpen(false)
        MessageScreenGui:Destroy()
    end)

    --Parent the message.
    MessageScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return self
end

--[[
Sets the window open or closed.
--]]
function R6Message:SetOpen(Open: boolean): ()
    warn(Open)
    --Determine the start and end values.
    local StartFieldOfView, EndFieldOfView = (Open and 0 or math.rad(40)), (Open and math.rad(40) or 0)

    --Show the message if it isn't visible.
    if Open then
        self.ScreenGui.Enabled = true
    end

    --Tween the field of view.
    local StartTime = tick()
    while tick() - StartTime < MESSAGE_OPEN_TIME do
        local Delta = (tick() - StartTime) / MESSAGE_OPEN_TIME
        Delta = (math.sin((Delta - 0.5) * math.pi) / 2) + 0.5
        self.ScreenGui.FieldOfView = StartFieldOfView + ((EndFieldOfView - StartFieldOfView) * Delta)
        RunService.RenderStepped:Wait()
    end

    --Hide thhe message if it is closed.
    if EndFieldOfView == 0 then
        self.ScreenGui.Enabled = false
    end
end

--[[
Opens the message.
--]]
function R6Message:Open(): ()
    self:SetOpen(true)
end



return R6Message]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXC4379FB742AD4F1B897AD5FC6EF46E45">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">View</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX5538AF15920145718DB0AED06D64B8B1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ApiBaseView</string>
							<string name="ScriptGuid">{F96DBBBD-79E1-44FE-B16E-8AC251783785}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Base view for the menu intended to be used with the API.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusInstance = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local ApiBaseView = NexusInstance:Extend()
ApiBaseView:SetClassName("ApiBaseView")

export type ApiBaseView = {
    new: (InitialName: string) -> ApiBaseView,
    Extend: (self: ApiBaseView) -> ApiBaseView,

    Name: string,
    Visible: boolean,
    Destroyed: NexusEvent.NexusEvent<>,
    GetContainer: (self: ApiBaseView) -> (Frame),
} & NexusInstance.NexusInstance



--[[
Creates the view.
--]]
function ApiBaseView:__new(InitialName: string): ()
    NexusInstance.__new(self)
    self.Name = InitialName
    self.Destroyed = NexusEvent.new()

    self.Frame = Instance.new("Frame")
    self.Frame.Name = tostring(self.Name)
    self.Frame.BackgroundTransparency = 1
    self.Frame.Size = UDim2.new(1, 0, 1, 0)
    self.Frame.Visible = false
    self.Frame.SizeConstraint = Enum.SizeConstraint.RelativeXX
    self:GetPropertyChangedSignal("Name"):Connect(function()
        self.Frame.Name = tostring(self.Name)
    end)
    self:GetPropertyChangedSignal("Visible"):Connect(function()
        self.Frame.Visible = self.Visible
    end)
end

--[[
Returns the containing frame.
--]]
function ApiBaseView:GetContainer(): Frame
    return self.Frame
end

--[[
Destroys the view.
--]]
function ApiBaseView:Destroy(): ()
    ApiBaseView.Destroy(self)
    self.Destroyed:Fire()
    self.Destroyed:Disconnect()
end



return (ApiBaseView :: any) :: ApiBaseView]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX283F1F8005BB4CE6BA78CB7AEB33C1CD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatView</string>
							<string name="ScriptGuid">{569249BA-BC29-4E48-96F5-3F7C600EBB8B}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

View for the chat.
Just moves the chat window. Does not
add any additional functionality.
--]]
--!strict

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusInstance = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local ChatView = NexusInstance:Extend()
ChatView:SetClassName("ChatView")



--[[
Creates the chat view.
--]]
function ChatView:__new(View: any): ()
    NexusInstance.__new(self)

    task.spawn(function()
        --Wait for a request to load the chat.
        --Starting release 544, the chat is loaded automatically.
        local Container = View:GetContainer()
        local LoadChatButton, LoadChatText = TextButtonFactory:Create()
        LoadChatButton.AnchorPoint = Vector2.new(0.5, 0.5)
        LoadChatButton.Size = UDim2.new(0.6, 0, 0.1, 0)
        LoadChatButton.Position = UDim2.new(0.5, 0, 0.5, 0)
        LoadChatButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
        LoadChatButton.Parent = Container
        LoadChatText.Text = "Load Chat"
        LoadChatButton.MouseButton1Down:Wait()
        LoadChatButton:Destroy()

        --Load the chat.
        --Taken from the main script.
        local Chat = require(Players.LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("ChatScript"):WaitForChild("ChatMain")) :: any
        local ClientChatModules = game:GetService("Chat"):WaitForChild("ClientChatModules")
        local ChatSettings = require(ClientChatModules:WaitForChild("ChatSettings")) :: any
        if not Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("Chat") then
            local containerTable = {}
            containerTable.ChatWindow = {}
            containerTable.SetCore = {}
            containerTable.GetCore = {}

            containerTable.ChatWindow.ChatTypes = {}
            containerTable.ChatWindow.ChatTypes.BubbleChatEnabled = ChatSettings.BubbleChatEnabled
            containerTable.ChatWindow.ChatTypes.ClassicChatEnabled = ChatSettings.ClassicChatEnabled

            --// Connection functions
            local function ConnectEvent(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.ChatWindow[name] = event

                event.Event:Connect(function(...) Chat[name](Chat, ...) end)
            end

            local function ConnectFunction(name)
                local func = Instance.new("BindableFunction")
                func.Name = name
                containerTable.ChatWindow[name] = func :: any

                func.OnInvoke = function(...) return Chat[name](Chat, ...) end
            end

            local function ReverseConnectEvent(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.ChatWindow[name] = event

                Chat[name]:Connect(function(...) event:Fire(...) end)
            end

            local function ConnectSignal(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.ChatWindow[name] = event

                event.Event:Connect(function(...) Chat[name]:fire(...) end)
            end

            local function ConnectSetCore(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.SetCore[name] = event

                event.Event:Connect(function(...) Chat[name.."Event"]:fire(...) end)
            end

            local function ConnectGetCore(name)
                local func = Instance.new("BindableFunction")
                func.Name = name
                containerTable.GetCore[name] = func

                func.OnInvoke = function(...) return Chat["f"..name](...) end
            end

            --// Do connections
            ConnectEvent("ToggleVisibility")
            ConnectEvent("SetVisible")
            ConnectEvent("FocusChatBar")
            ConnectEvent("EnterWhisperState")
            ConnectFunction("GetVisibility")
            ConnectFunction("GetMessageCount")
            ConnectEvent("TopbarEnabledChanged")
            ConnectFunction("IsFocused")

            ReverseConnectEvent("ChatBarFocusChanged")
            ReverseConnectEvent("VisibilityStateChanged")
            ReverseConnectEvent("MessagesChanged")
            ReverseConnectEvent("MessagePosted")

            ConnectSignal("CoreGuiEnabled")

            ConnectSetCore("ChatMakeSystemMessage")
            ConnectSetCore("ChatWindowPosition")
            ConnectSetCore("ChatWindowSize")
            ConnectGetCore("ChatWindowPosition")
            ConnectGetCore("ChatWindowSize")
            ConnectSetCore("ChatBarDisabled")
            ConnectGetCore("ChatBarDisabled")
        end

        --Move the chat GUI to the container.
        local ChatWindow = Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("Chat")
        while #ChatWindow:GetChildren() == 0 do task.wait() end
        local ChatFrame = ChatWindow:FindFirstChildOfClass("Frame")
        ChatFrame.Size = UDim2.new(1, 0, 1, 0)
        ChatFrame.Parent = Container

        --Connect starting chat.
        --For some reason, it is not done when VR is enabled.
        UserInputService.InputBegan:Connect(function(Input,Processed)
            if Processed then return end
            if not UserInputService:GetFocusedTextBox() and Input.KeyCode == Enum.KeyCode.Slash and Container.Visible then
                --Focus the chat bar.
                --Done the next frame so that the slash is not inputted.
                RunService.Stepped:Wait()
                Chat:FocusChatBar()
            end
        end)

        --Force the GUI to always be visible.
        --Bit hacky and relies on checking for the passed value to be not false and not nil instead of checking if it true.
        while true do
            Chat:SetVisible(tick())
            task.wait(0.1)
        end
    end)
end




return ChatView]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5AEC33F1CFA14FDBB9CA16EFA6565EF0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SettingsView</string>
							<string name="ScriptGuid">{37640F32-4595-48A0-9E4A-317BEFEFD446}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

View for the user settings.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusInstance = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
local ControlService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")).GetInstance()
local DefaultCursorService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("DefaultCursorService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local SettingsView = NexusInstance:Extend()
SettingsView:SetClassName("SettingsView")



--[[
Creates the settings view.
--]]
function SettingsView:__new(View: any): ()
    NexusInstance.__new(self)

    --Create the header.
    local Container = View:GetContainer()
    local HeaderLogo = Instance.new("ImageLabel")
    HeaderLogo.BackgroundTransparency = 1
    HeaderLogo.Size = UDim2.new(0.4, 0, 0.4, 0)
    HeaderLogo.Position = UDim2.new(0.3, 0, -0.1, 0)
    HeaderLogo.Image = "http://www.roblox.com/asset/?id=1499731139"
    HeaderLogo.Parent = Container

    local NameText = Instance.new("TextLabel")
    NameText.BackgroundTransparency = 1
    NameText.Size = UDim2.new(0.8, 0, 0.1, 0)
    NameText.Position = UDim2.new(0.1, 0, 0.2, 0)
    NameText.Font = Enum.Font.SourceSansBold
    NameText.Text = "Nexus VR Character Model"
    NameText.TextScaled = true
    NameText.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    NameText.TextStrokeTransparency = 0
    NameText.Parent = Container

    --Create the settings.
    local CameraSettingFrame = Instance.new("Frame")
    CameraSettingFrame.BackgroundTransparency = 1
    CameraSettingFrame.Size = UDim2.new(0.8, 0,0.11, 0)
    CameraSettingFrame.Position = UDim2.new(0.1, 0, 0.325, 0)
    CameraSettingFrame.Parent = Container
    self:PopulateSettingsFrame(CameraSettingFrame, "View", "Camera.EnabledCameraOptions", function()
        return CameraService.ActiveCamera
    end, function(NewValue)
        CameraService:SetActiveCamera(NewValue)
    end)

    local MovementSettingFrame = Instance.new("Frame")
    MovementSettingFrame.BackgroundTransparency = 1
    MovementSettingFrame.Size = UDim2.new(0.8, 0, 0.11, 0)
    MovementSettingFrame.Position = UDim2.new(0.1, 0, 0.325 + (0.15 * 1), 0)
    MovementSettingFrame.Parent = Container
    self:PopulateSettingsFrame(MovementSettingFrame, "Control", "Movement.EnabledMovementMethods", function()
        return ControlService.ActiveController
    end, function(NewValue)
        ControlService:SetActiveController(NewValue)
    end)

    local CursorSettingFrame = Instance.new("Frame")
    CursorSettingFrame.BackgroundTransparency = 1
    CursorSettingFrame.Size = UDim2.new(0.8, 0, 0.11, 0)
    CursorSettingFrame.Position = UDim2.new(0.1, 0, 0.325 + (0.15 * 2), 0)
    CursorSettingFrame.Parent = Container
    self:PopulateSettingsFrame(CursorSettingFrame, "Roblox VR Cursor", function()
        return DefaultCursorService.CursorOptionsList
    end, function()
        return DefaultCursorService.CurrentCursorState
    end, function(NewValue)
        DefaultCursorService:SetCursorState(NewValue)
    end)

    --Create the callibration settings.
    local RecenterButton,RecenterText = TextButtonFactory:Create()
    RecenterButton.Size = UDim2.new(0.4, 0, 0.075, 0)
    RecenterButton.Position = UDim2.new(0.075, 0, 0.85, 0)
    RecenterButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    RecenterButton.Parent = Container
    RecenterText.Text = "Recenter"

    RecenterButton.MouseButton1Down:Connect(function()
        VRInputService:Recenter()
    end)

    local SetEyeLevelButton,SetEyeLevelText = TextButtonFactory:Create()
    SetEyeLevelButton.Size = UDim2.new(0.4, 0, 0.075, 0)
    SetEyeLevelButton.Position = UDim2.new(0.525, 0, 0.85, 0)
    SetEyeLevelButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    SetEyeLevelButton.Parent = Container
    SetEyeLevelText.Text = " Set Eye Level "

    SetEyeLevelButton.MouseButton1Down:Connect(function()
        VRInputService:SetEyeLevel()
    end)
end

--[[
Popuulates a setting frame.
--]]
function SettingsView:PopulateSettingsFrame(ContainerFrame: Frame, HeaderName: string, GetOptionsSettings: () -> ({string}), GetValueFunction: () -> (string), SetValueFunction: (string) -> ()?): ()
    --Converrt the GetOptionsSettings callback if it is a string.
    local OptionsSetting = nil
    if typeof(GetOptionsSettings) == "string" then
        OptionsSetting = GetOptionsSettings
        GetOptionsSettings = function()
            return Settings:GetSetting(OptionsSetting) or {}
        end
    end

    --Create the frames.
    local LeftButton,LeftText = TextButtonFactory:Create()
    LeftButton.Size = UDim2.new(1, 0, 1, 0)
    LeftButton.Position = UDim2.new(0, 0, 0, 0)
    LeftButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    LeftButton.Parent = ContainerFrame
    LeftText.Text = "<"

    local RightButton,RightText = TextButtonFactory:Create()
    RightButton.AnchorPoint = Vector2.new(1, 0)
    RightButton.Size = UDim2.new(1, 0, 1, 0)
    RightButton.Position = UDim2.new(1, 0, 0, 0)
    RightButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    RightButton.Parent = ContainerFrame
    RightText.Text = ">"

    local OptionHeaderText = Instance.new("TextLabel")
    OptionHeaderText.BackgroundTransparency = 1
    OptionHeaderText.Size = UDim2.new(0.8, 0, 0.5, 0)
    OptionHeaderText.Position = UDim2.new(0.1, 0, -0.0125, 0)
    OptionHeaderText.Font = Enum.Font.SourceSansBold
    OptionHeaderText.Text = HeaderName
    OptionHeaderText.TextScaled = true
    OptionHeaderText.TextColor3 = Color3.fromRGB(255, 255, 255)
    OptionHeaderText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    OptionHeaderText.TextStrokeTransparency = 0
    OptionHeaderText.Parent = ContainerFrame

    local OptionText = Instance.new("TextLabel")
    OptionText.BackgroundTransparency = 1
    OptionText.Size = UDim2.new(0.6, 0, 0.7, 0)
    OptionText.Position = UDim2.new(0.2, 0, 0.3, 0)
    OptionText.Font = Enum.Font.SourceSansBold
    OptionText.TextScaled = true
    OptionText.TextColor3 = Color3.fromRGB(255, 255, 255)
    OptionText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    OptionText.TextStrokeTransparency = 0
    OptionText.Parent = ContainerFrame

    --[[
    Updates the settings.
    --]]
    local function UpdateSettings(Increment: number?): ()
        --Get the current value id.
        local InitialValueName = GetValueFunction()
        local CurrentValue = 1
        local Options = GetOptionsSettings()
        for i,Option in pairs(Options) do
            if Option == InitialValueName then
                CurrentValue = i
                break
            end
        end

        --Increment the value.
        if Increment and Increment ~= 0 then
            CurrentValue = CurrentValue + Increment
            if CurrentValue <= 0 then
                CurrentValue = #Options
            end
            if CurrentValue > #Options then
                CurrentValue = 1
            end
        end

        --Update the button visibility.
        LeftButton.Visible = (#Options > 1)
        RightButton.Visible = (#Options > 1)

        --Update the display text.
        OptionText.Text = Options[CurrentValue] or "(N/A)"

        --Set the new value.
        if Increment and Increment ~= 0 and Options[CurrentValue] then
            (SetValueFunction :: (string) -> ())(Options[CurrentValue])
        end
    end

    --Connect the events.
    local DB = true
    if OptionsSetting then
        Settings:GetSettingsChangedSignal(OptionsSetting):Connect(UpdateSettings)
    end
    LeftButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        UpdateSettings(-1)
        task.wait()
        DB = true
    end)
    RightButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        UpdateSettings(1)
        task.wait()
        DB = true
    end)

    --Update the initial settings.
    UpdateSettings()
end



return SettingsView]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX36E0F09880554B269A9F92098E9637C9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX4CDE147E870949B7815AA2EA6E91FB3E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FindCollidablePartOnRay</string>
						<string name="ScriptGuid">{EB8790C0-21A1-4DF8-AFCE-82123CAC1CE5}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Helper function that ray casts to
find a collidable part.
--]]
--!strict

local Workspace = game:GetService("Workspace")



--[[
Ray casts to find a collidable part.
--]]
local function FindCollidablePartOnRay(StartPosition: Vector3, Direction: Vector3, IgnoreList: Instance | {Instance}?, CollisionGroup: string?): (BasePart?, Vector3)
    --Convert the collision group.
    if typeof(CollisionGroup) == "Instance" and CollisionGroup:IsA("BasePart") then
        CollisionGroup = CollisionGroup.CollisionGroup
    end

    --Create the ignore list.
    local Camera = Workspace.CurrentCamera
    local NewIgnoreList = {Camera}
    if typeof(IgnoreList) == "Instance" then
        table.insert(NewIgnoreList, IgnoreList)
    elseif typeof(IgnoreList) == "table" then
        for _, Entry in IgnoreList do
            if Entry ~= Camera then
                table.insert(NewIgnoreList, Entry)
            end
        end
    end

    --Create the parameters.
    local RaycastParameters = RaycastParams.new()
    RaycastParameters.FilterType = Enum.RaycastFilterType.Blacklist
    RaycastParameters.FilterDescendantsInstances = NewIgnoreList
    RaycastParameters.IgnoreWater = true
    if CollisionGroup then
        RaycastParameters.CollisionGroup = CollisionGroup
    end

    --Raycast and continue if the hit part isn't collidable.
    local RaycastResult = Workspace:Raycast(StartPosition, Direction, RaycastParameters)
    if not RaycastResult then
        return nil, StartPosition + Direction
    end
    local HitPart,EndPosition = RaycastResult.Instance, RaycastResult.Position
    if HitPart and not HitPart.CanCollide and (not HitPart:IsA("Seat") or not HitPart:IsA("VehicleSeat") or HitPart.Disabled) then
        table.insert(NewIgnoreList, HitPart)
        return FindCollidablePartOnRay(EndPosition, Direction + (EndPosition - StartPosition), NewIgnoreList, CollisionGroup)
    end

    --Return the hit result.
    return HitPart, EndPosition
end



return FindCollidablePartOnRay]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6D5A698E06984EF7821889CFDFC3C4AA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Warnings</string>
						<string name="ScriptGuid">{C9BF2B34-EAFA-4CE8-BF55-E920E8D9F105}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Displays warnings when loading Nexus VR Character Model.
--]]
--!strict

local HttpService = game:GetService("HttpService")



return function(): ()
    --Load the configuration.
    local ConfigurationValue = script.Parent.Parent:WaitForChild("Configuration")
    local Configuration = HttpService:JSONDecode(ConfigurationValue.Value)

    --Determine the suppressed warnings.
    local SupressedWarnings = {}
    if Configuration.Output and Configuration.Output.SuppressWarnings then
        for _, WarningName in Configuration.Output.SuppressWarnings do
            SupressedWarnings[string.lower(WarningName)] = true
        end
    end
    if SupressedWarnings["all"] then return end

    --Build the warnings.
    local Warnings = {
        {
            Key = "MissingNexusVRBackpackEnabled",
            Message = "The configuration entry Extra.NexusVRBackpackEnabled is missing (defaults to true).",
            Condition = function()
               return Configuration.Extra == nil or Configuration.Extra.NexusVRBackpackEnabled == nil
            end
        },
        {
            Key = "MissingAllowClientToOutputLoadedMessage",
            Message = "The configuration entry Extra.AllowClientToOutputLoadedMessage is missing (defaults to true).",
            Condition = function()
               return Configuration.Output == nil or Configuration.Output.AllowClientToOutputLoadedMessage == nil
            end
        },
    }

    --Output the warnings.
    for _, Warning in Warnings do
        if not SupressedWarnings[string.lower(Warning.Key)] and Warning.Condition() then
            warn(Warning.Message)
            warn("\tThis warning can be disabled by adding \""..Warning.Key.."\" or \"All\" to Output.SuppressWarnings in the configuration of Nexus VR Character Model.")
        end
    end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXDDDE73C96E334491848DECAB6A937585">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NexusButton</string>
					<string name="ScriptGuid">{B1A9EB53-3BB1-467A-B85F-A796F1CD4D1D}</string>
					<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Main module representing the button class. This button
is meant to provide an easy way to make "good looking",
cross platform buttons.
--]]
--!strict

local HOVER_COLOR_MULTIPLIER = 0.7
local PRESS_COLOR_MULTIPLIER = 1 / 0.7
local CONTROLLER_SECTION_COLOR = Color3.new(50 / 255, 50 / 255, 50 / 255)
local DEFAULT_THEMES = {
    CutCorners = {
        MainButton = {
            Image = "rbxassetid://9708818802",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9708824372",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
    CutTopLeftCorner = {
        MainButton = {
            Image = "rbxassetid://9708819815",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9708825225",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
    CutBottomRightCorner = {
        MainButton = {
            Image = "rbxassetid://9708824372",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9708824372",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
    RoundedCorners = {
        MainButton = {
            Image = "rbxassetid://9704725601",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9704725809",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
}



local GuiService = game:GetService("GuiService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local ControllerIcon = require(script:WaitForChild("ControllerIcon"))
local NexusWrappedInstance = require(script:WaitForChild("NexusWrappedInstance"))

local NexusButton = NexusWrappedInstance:Extend()
NexusButton.Themes = DEFAULT_THEMES
NexusButton:SetClassName("NexusButton")

export type NexusButtonTheme = {
    MainButton: {
        Image: string,
        SliceCenter: Rect,
        SliceScaleMultiplier: number,
    },
    GamepadIconBackground: {
        Image: string,
        SliceCenter: Rect,
        SliceScaleMultiplier: number,
    },
}
export type NexusButton = {
    new: () -> NexusButton,
    Extend: (self: NexusButton) -> NexusButton,

    BorderSizeScale: number,
    TweenDuration: number,
    Theme: string,
    OverrideButtonProperty: (self: NexusButton, PropertyName: string, SetFunction: (any) -> ()) -> (),
    GetAdornFrame: (self: NexusButton) -> Frame,
    SetControllerIcon: (self: NexusButton, KeyCode: Enum.KeyCode | string) -> (),
    MapKey: (self: NexusButton, KeyCode: Enum.KeyCode | string, MouseInput: Enum.UserInputType | string) -> (),
    UnmapKey: (KeyCode: Enum.KeyCode | string) -> (),
} & NexusWrappedInstance.NexusWrappedInstance & TextButton



--[[
Multiplies a Color3.
--]]
local function MultiplyColor3(Color: Color3, Multiplier: number): Color3
    return Color3.new(math.clamp(Color.R * Multiplier, 0, 1), math.clamp(Color.G * Multiplier, 0, 1), math.clamp(Color.B * Multiplier, 0, 1))
end

--[[
Creates a Nexus Button object.
--]]
function NexusButton:__new(): ()
    NexusWrappedInstance.__new(self, "TextButton")

    --Create the frames.
    local BaseButton = self:GetWrappedInstance()
    BaseButton.BackgroundTransparency = 1
    BaseButton.Text = ""

    local BorderFrame = Instance.new("ImageLabel")
    BorderFrame.BackgroundTransparency = 1
    BorderFrame.ScaleType = Enum.ScaleType.Slice
    BorderFrame.Parent = BaseButton
    self:DisableChangeReplication("BorderFrame")
    self.BorderFrame = BorderFrame

    local BackgroundFrame = Instance.new("ImageLabel")
    BackgroundFrame.BackgroundTransparency = 1
    BackgroundFrame.Size = UDim2.new(1, 0, 1, 0)
    BackgroundFrame.ZIndex = 2
    BackgroundFrame.ScaleType = Enum.ScaleType.Slice
    BackgroundFrame.Parent = BaseButton
    self:DisableChangeReplication("BackgroundFrame")
    self.BackgroundFrame = BackgroundFrame

    BackgroundFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        self:UpdateSliceScale()
        self:UpdateBorder(false)
    end)

    local ContentsAdorn = Instance.new("Frame")
    ContentsAdorn.BackgroundTransparency = 1
    ContentsAdorn.Size = UDim2.new(1, 0, 1, 0)
    ContentsAdorn.ZIndex = 3
    ContentsAdorn.Parent = BaseButton
    self:DisableChangeReplication("ContentsAdorn")
    self.ContentsAdorn = ContentsAdorn

    local GamepadIcon = ControllerIcon.new()
    GamepadIcon.AdornFrame.ImageColor3 = CONTROLLER_SECTION_COLOR
    GamepadIcon.AdornFrame.Size = UDim2.new(1, 0, 1, 0)
    GamepadIcon.AdornFrame.Position = UDim2.new(1, 0, 0, 0)
    GamepadIcon.AdornFrame.SizeConstraint = Enum.SizeConstraint.RelativeYY
    GamepadIcon.AdornFrame.AnchorPoint = Vector2.new(1, 0)
    GamepadIcon.AdornFrame.ZIndex = 4
    GamepadIcon.AdornFrame.ScaleType = Enum.ScaleType.Slice
    GamepadIcon.AdornFrame.Parent = BaseButton
    self:DisableChangeReplication("GamepadIcon")
    self.GamepadIcon = GamepadIcon

    --Connect replicating values.
    local ButtonPropertyOverrides = {}
    self:DisableChangeReplication("ButtonPropertyOverrides")
    self.ButtonPropertyOverrides = ButtonPropertyOverrides
    self:AddGenericPropertyFinalizer(function(PropertyName: string, Value: any)
        if not ButtonPropertyOverrides[PropertyName] then
            return
        end
        ButtonPropertyOverrides[PropertyName](Value)
    end)

    --Set the replication overrides.
    self:DisableChangeReplication("TweenDuration")
    self:OverrideButtonProperty("BackgroundColor3", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("BackgroundTransparency", function(NewBackgroundTransparency: number)
        BackgroundFrame.ImageTransparency = NewBackgroundTransparency
    end)
    self:OverrideButtonProperty("BorderSize", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("BorderSizePixel", function(NewBorderSizePixel: number)
        self.BorderSize = UDim.new(0, NewBorderSizePixel)
    end)
    self:OverrideButtonProperty("BorderSizeScale", function(NewBorderSizeScale: number)
        self.BorderSize = UDim.new(NewBorderSizeScale, 0)
    end)
    self:OverrideButtonProperty("BorderColor3", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("AutoButtonColor", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("BorderTransparency", function(NewBorderTransparency: number)
        BorderFrame.ImageTransparency = NewBorderTransparency
    end)
    self:OverrideButtonProperty("Hovering", function()
        self:UpdateBorder(true)
    end)
    self:OverrideButtonProperty("Pressed", function()
        self:UpdateBorder(true)
    end)
    self:OverrideButtonProperty("Theme", function(NewTheme: string)
        local Theme = NexusButton.Themes[NewTheme]
        if not Theme then
            error("Unknown theme: "..tostring(NewTheme))
        end
        BackgroundFrame.Image = Theme.MainButton.Image
        BackgroundFrame.SliceCenter = Theme.MainButton.SliceCenter
        BorderFrame.Image = Theme.MainButton.Image
        BorderFrame.SliceCenter = Theme.MainButton.SliceCenter
        GamepadIcon.AdornFrame.Image = Theme.GamepadIconBackground.Image
        GamepadIcon.AdornFrame.SliceCenter = Theme.GamepadIconBackground.SliceCenter
        self:UpdateSliceScale()
    end)

    --Connect the events.
    self:DisableChangeReplication("MappedInputs")
    self.MappedInputs = {}
    self:DisableChangeReplication("Events")
    self.Events = {}
    self.MouseEnter:Connect(function()
        self.Hovering = true
    end)
    self.MouseLeave:Connect(function()
        self.Hovering = false
    end)
    self.MouseButton1Down:Connect(function()
        self.Pressed = true
    end)
    self.MouseButton1Up:Connect(function()
        self.Pressed = false
    end)
    table.insert(self.Events, GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(function()
        self:UpdateBorder(true)
    end))
    table.insert(self.Events, UserInputService.InputBegan:Connect(function(Input, Processed)
        if Processed and (GuiService.SelectedObject ~= self:GetWrappedInstance() or Input.KeyCode == Enum.KeyCode.ButtonA) then return end
        if self.Pressed then return end
        if not self.MappedInputs[Input.KeyCode] then return end

        local MouseInput = self.MappedInputs[Input.KeyCode]
        if MouseInput == Enum.UserInputType.MouseButton1 then
            self.MouseButton1Down:Fire()
        elseif MouseInput == Enum.UserInputType.MouseButton2 then
            self.MouseButton2Down:Fire()
        end
    end))
    table.insert(self.Events, UserInputService.InputEnded:Connect(function(Input)
        if not self.Pressed then return end
        if not self.MappedInputs[Input.KeyCode] then return end

        local MouseInput = self.MappedInputs[Input.KeyCode]
        if MouseInput == Enum.UserInputType.MouseButton1 then
            self.MouseButton1Up:Fire()
            self.MouseButton1Click:Fire()
        elseif MouseInput == Enum.UserInputType.MouseButton2 then
            self.MouseButton2Up:Fire()
            self.MouseButton2Click:Fire()
        end
    end))
    table.insert(self.Events, UserInputService.InputEnded:Connect(function(Input)
        if not self.Pressed then return end
        if Input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        self.Pressed = false
    end))

    --Set the defaults.
    self.Size = UDim2.new(0, 200, 0, 50)
    self.BackgroundColor3 = Color3.new(0.8, 0.8, 0.8)
    self.BackgroundTransparency = 0
    self.BorderSize = UDim.new(0.15, 0)
    self.BorderColor3 = Color3.new(0, 0, 0)
    self.BorderTransparency = 0
    self.AutoButtonColor = true
    self.Hovering = false
    self.Pressed = false
    self.TweenDuration = 0.1
    self.Theme = "CutCorners"
end

--[[
Overrides the replication of a property for the button.
--]]
function NexusButton:OverrideButtonProperty(PropertyName: string, SetFunction: (any) -> ()): ()
    self:DisableChangeReplication(PropertyName)
    self.ButtonPropertyOverrides[PropertyName] = SetFunction
end

--[[
Updates the slice scales of the background and border.
--]]
function NexusButton:UpdateSliceScale(): ()
    local Theme = NexusButton.Themes[self.Theme]
    local ButtonSize = math.min(self.AbsoluteSize.X, self.AbsoluteSize.Y)
    local SliceScale = ButtonSize * Theme.MainButton.SliceScaleMultiplier
    self.BackgroundFrame.SliceScale = SliceScale
    self.BorderFrame.SliceScale = SliceScale
    self.GamepadIcon.AdornFrame.SliceScale = SliceScale
end

--[[
Updates the background and border properties.
--]]
function NexusButton:UpdateBorder(Tween: boolean?): ()
    --Get the border size.
    if not self.BorderSize then return end
    if not self.Theme then return end
    local ButtonSizeY = self.BackgroundFrame.AbsoluteSize.Y
    local BorderSize = (ButtonSizeY * self.BorderSize.Scale) + self.BorderSize.Offset
    local BackgroundColor3 = self.BackgroundColor3
    local BorderColor3 = self.BorderColor3

    --Modify the properties.
    if self.AutoButtonColor ~= false then
        if self.Pressed then
            BackgroundColor3 = MultiplyColor3(BackgroundColor3, PRESS_COLOR_MULTIPLIER)
            BorderColor3 = MultiplyColor3(BorderColor3, PRESS_COLOR_MULTIPLIER)
            BorderSize = BorderSize * 0.25
        elseif self.Hovering or GuiService.SelectedObject == self:GetWrappedInstance() then
            BackgroundColor3 = MultiplyColor3(BackgroundColor3, HOVER_COLOR_MULTIPLIER)
            BorderColor3 = MultiplyColor3(BorderColor3, HOVER_COLOR_MULTIPLIER)
            BorderSize = BorderSize * 0.75
        end
    end

    --Apply the properties.
    if Tween and self.TweenDuration and self.TweenDuration > 0 then
        TweenService:Create(self.BackgroundFrame:GetWrappedInstance(), TweenInfo.new(self.TweenDuration), {
            ImageColor3 = BackgroundColor3,
        }):Play()
        TweenService:Create(self.BorderFrame:GetWrappedInstance(), TweenInfo.new(self.TweenDuration), {
            ImageColor3 = BorderColor3,
            Size = UDim2.new(1, 0, 1, BorderSize),
        }):Play()
    else
        self.BackgroundFrame.ImageColor3 = BackgroundColor3
        self.BorderFrame.ImageColor3 = BorderColor3
        self.BorderFrame.Size = UDim2.new(1, 0, 1, BorderSize)
    end
end

--[[
Returns the adorn frame to parent frames to the button.
--]]
function NexusButton:GetAdornFrame(): Frame
    return self.ContentsAdorn:GetWrappedInstance()
end

--[[
Sets the controller icon for the button.
--]]
function NexusButton:SetControllerIcon(KeyCode: Enum.KeyCode | string): ()
    self.GamepadIcon:SetIcon(KeyCode)
end

--[[
Maps a key input to a mouse input for clicking.
--]]
function NexusButton:MapKey(KeyCode: Enum.KeyCode | string, MouseInput: Enum.UserInputType | string): ()
    --Correct the inputs.
    if typeof(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end
    if typeof(MouseInput) == "string" then
        MouseInput = (Enum.UserInputType :: any)[MouseInput]
    end

    --Throw an error if the mouse input is invalid.
    if MouseInput ~= Enum.UserInputType.MouseButton1 and MouseInput ~= Enum.UserInputType.MouseButton2 then
        error("Mouse input must be either MouseButton1 or MouseButton2.")
    end

    --Store the mapped input.
    self.MappedInputs[KeyCode] = MouseInput
end

--[[
Unmaps a key input to a mouse input for clicking.
--]]
function NexusButton:UnmapKey(KeyCode: Enum.KeyCode | string): ()
    --Correct the input.
    if typeof(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end

    --Remove the mapped input.
    self.MappedInputs[KeyCode] = nil
end

--[[
Destroys the button and disconnects the events.
--]]
function NexusButton:Destroy(): ()
    NexusWrappedInstance.Destroy(self)
    self.GamepadIcon:Destroy()

    --Disconnect the events.
    for _, Event in self.Events do
        Event:Disconnect()
    end
    self.Events = {}
end



return NexusButton :: NexusButton]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX98F62319C2AD450C8B8A5A993CD5C025">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ControllerIcon</string>
						<string name="ScriptGuid">{EBE8BA74-76B5-4814-9E2E-ECF5E552CEED}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Class representing a controller icon.
--]]
--!strict

local BASE_ICON_SIZE_RELATIVE = 0.9
local CUSTOM_MULTIPLIERS = {
    [Enum.KeyCode.ButtonL1] = {1, 0.5},
    [Enum.KeyCode.ButtonR1] = {1, 0.5},
}



local UserInputService = game:GetService("UserInputService")

local ControllerIconCreator = require(script:WaitForChild("ControllerIconCreator"))
local NexusInstance = require(script.Parent:WaitForChild("NexusWrappedInstance"):WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))

local ControllerIcon = NexusInstance:Extend()
ControllerIcon:SetClassName("ControllerIcon")

export type ControllerIcon = {
    new: () -> ControllerIcon,
    Extend: (self: ControllerIcon) -> ControllerIcon,

    SetIcon: (self: ControllerIcon, KeyCode: Enum.KeyCode | string) -> (),
    SetScale: (self: ControllerIcon, NewScale: number) -> (),
} & NexusInstance.NexusInstance



--[[
Constructor of the Controller Icon class.
--]]
function ControllerIcon:__new()
    NexusInstance.__new(self)

    --Create the adorn frame.
    local AdornFrame = Instance.new("ImageLabel")
    AdornFrame.BackgroundTransparency = 1
    self.AdornFrame = AdornFrame
    self.IconScale = BASE_ICON_SIZE_RELATIVE

    --Connect the events.
    self.Events = {}
    table.insert(self.Events, UserInputService.GamepadConnected:Connect(function()
        self:UpdateVisibility()
    end))
    table.insert(self.Events, UserInputService.GamepadDisconnected:Connect(function()
        self:UpdateVisibility()
    end))

    --Update the visibility.
    self:UpdateVisibility()
end

--[[
Updates the visibility of the icon.
--]]
function ControllerIcon:UpdateVisibility(): ()
    --Set the visibility to false if there is no icon.
    if not self.Icon then
        self.AdornFrame.Visible = false
        self.IconVisible = false
        return
    end

    --Determine if a controller is connected.
    local ControllerConnected = (#UserInputService:GetConnectedGamepads() ~= 0)

    --Set the visibility.
    self.AdornFrame.Visible = ControllerConnected
    self.IconVisible = ControllerConnected
end

--[[
Sets the icon.
--]]
function ControllerIcon:SetIcon(KeyCode: Enum.KeyCode | string): ()
    --Return if the KeyCode is nil.
    if KeyCode == nil then
        self.KeyCode = nil
        self.Icon:Destroy()
        self.Icon = nil
        self:UpdateVisibility()
        return
    end

    --Covert the KeyCode from a string.
    if type(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end

    --Destroy the existing icon.
    if self.Icon then
        self.Icon:Destroy()
    end

    --Create the new icon.
    local Icon = ControllerIconCreator:GetImageLabel(KeyCode, "Dark", "XboxOne")
    Icon.Position = UDim2.new(0.5, 0, 0.5, 0)
    Icon.AnchorPoint = Vector2.new(0.5, 0.5)
    Icon.ZIndex = self.AdornFrame.ZIndex
    Icon.Parent = self.AdornFrame
    self.Icon = Icon
    self.KeyCode = KeyCode
    self:UpdateVisibility()
    self:SetScale(self.IconScale)
end

--[[
Sets the scale of the icon.
--]]
function ControllerIcon:SetScale(NewScale: number): ()
    self.IconScale = NewScale

    --Set the size.
    if self.KeyCode and self.Icon then
        local ScaleMultipliers = CUSTOM_MULTIPLIERS[self.KeyCode] or {1, 1}
        self.Icon.Size = UDim2.new(self.IconScale * ScaleMultipliers[1], 0, self.IconScale * ScaleMultipliers[2], 0)
    end
end

--[[
Destroys the frame.
--]]
function ControllerIcon:Destroy(): ()
    NexusInstance.Destroy(self)

    --Disconnect the events.
    for _,Event in self.Events do
        Event:Disconnect()
    end
    self.Events = {}

    --Destroy the adorn frame.
    self.AdornFrame:Destroy()
end



return ControllerIcon :: ControllerIcon]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3E5673DB998D4BD2A0E0E6A2DBEFB901">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ControllerIconCreator</string>
							<string name="ScriptGuid">{956E3EEC-05CF-4392-8784-C3045788257B}</string>
							<ProtectedString name="Source"><![CDATA[local ControllerImageLibrary = {}

local spritesheets = {}
for _, platform in pairs(script.Spritesheets:GetChildren()) do
    spritesheets[platform.Name] = {}
    for _, style in pairs(platform:GetChildren()) do
        spritesheets[platform.Name][style.Name] = require(style).new()
    end
end

local function getImageInstance(instanceType, index, style)
    local platform = "XboxOne"
    if type(index)== "userdata" then
        index = string.sub(tostring(index), 14)
    end
    local sheet = spritesheets[platform][style]
    if not sheet then
        warn("Could not find style: " .. style)
        return
    end
    local element = sheet:GetSprite(instanceType, index)
    return element
end

function ControllerImageLibrary:GetImageLabel(index, style, platform)
    return getImageInstance("ImageLabel", index, style, platform)
end

function ControllerImageLibrary:GetImageButton(index, style, platform)
    return getImageInstance("ImageButton", index, style, platform)
end

return ControllerImageLibrary
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX752D866904A14E40822F4D66CA20B76B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Spritesheet</string>
								<string name="ScriptGuid">{F463A30B-BD42-454C-AC86-68EAB6C68685}</string>
								<ProtectedString name="Source"><![CDATA[local Spritesheet = {}
Spritesheet.__index = Spritesheet

function Spritesheet.new(texture)
    local newSpritesheet = {}
    setmetatable(newSpritesheet, Spritesheet)
    
    newSpritesheet.Texture = texture
    newSpritesheet.Sprites = {}    
    
    return newSpritesheet
end

function Spritesheet:AddSprite(index, position, size)
    local Sprite = {Position=position,Size=size}
    self.Sprites[index] = Sprite
end

function Spritesheet:GetSprite(instanceType, index)
    if not index then
        warn("Image name cannot be nil")
        return false
    end
    local sprite = self.Sprites[index]
    if not sprite then 
        warn("Could not find sprite for: " .. index) 
        return false
    end
    local element = Instance.new(instanceType)
    element.BackgroundTransparency = 1
    element.BorderSizePixel = 1
    element.Image = self.Texture
    element.Size = UDim2.new(0, sprite.Size.X, 0, sprite.Size.Y)
    element.ImageRectOffset = sprite.Position
    element.ImageRectSize = sprite.Size
    
    return element
end

return Spritesheet
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX3153F3D625554840810D51CF5C4D74AF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Spritesheets</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXAD818B91BE10493EA018374D56748B67">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">XboxOne</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXF67AE7F4651940A0A70483F6C8F427D9">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Dark</string>
										<string name="ScriptGuid">{3F5103A0-A4F4-4589-A0EF-F6F80420EB01}</string>
										<ProtectedString name="Source"><![CDATA[local Spritesheet = require(script.Parent.Parent.Parent.Spritesheet)
local Dark = {}
Dark.__index = Dark
setmetatable(Dark, Spritesheet)

local darkTexture = "rbxassetid://408444495"

function Dark.new()
    local newDark = Spritesheet.new(darkTexture)
    setmetatable(newDark, Dark)
    
    newDark:AddSprite("ButtonX", Vector2.new(510, 416), Vector2.new(95, 95))    
    newDark:AddSprite("ButtonY", Vector2.new(616, 318), Vector2.new(95, 95))
    newDark:AddSprite("ButtonA", Vector2.new(318, 416), Vector2.new(95, 95))
    newDark:AddSprite("ButtonB", Vector2.new(520, 522), Vector2.new(95, 95))
    newDark:AddSprite("ButtonR1", Vector2.new(0, 628), Vector2.new(115, 64))
    newDark:AddSprite("ButtonL1", Vector2.new(116, 628), Vector2.new(115, 64))
    newDark:AddSprite("ButtonR2", Vector2.new(616, 414), Vector2.new(105, 115))
    newDark:AddSprite("ButtonL2", Vector2.new(616, 0), Vector2.new(105, 115))
    newDark:AddSprite("ButtonR3", Vector2.new(0, 416), Vector2.new(105, 105))
    newDark:AddSprite("ButtonL3", Vector2.new(0, 522), Vector2.new(105, 105))
    newDark:AddSprite("ButtonSelect", Vector2.new(424, 522), Vector2.new(95, 95))
    newDark:AddSprite("DPadLeft", Vector2.new(318, 522), Vector2.new(105, 105))
    newDark:AddSprite("DPadRight", Vector2.new(212, 416), Vector2.new(105, 105))
    newDark:AddSprite("DPadUp", Vector2.new(616, 530), Vector2.new(105, 105))
    newDark:AddSprite("DPadDown", Vector2.new(212, 522), Vector2.new(105, 105))
    newDark:AddSprite("Thumbstick1", Vector2.new(616, 116), Vector2.new(105, 105))    
    newDark:AddSprite("Thumbstick2", Vector2.new(106, 522), Vector2.new(105, 105))
    newDark:AddSprite("DPad", Vector2.new(106, 416), Vector2.new(105, 105))
    newDark:AddSprite("Controller", Vector2.new(0, 0), Vector2.new(615, 415))
    newDark:AddSprite("RotateThumbstick1", Vector2.new(414, 416), Vector2.new(95, 95))
    newDark:AddSprite("RotateThumbstick2", Vector2.new(616, 222), Vector2.new(95, 95))
    
    return newDark
end

return Dark
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2376C47FA97D4A899DAE2BDAD766C5E3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Light</string>
										<string name="ScriptGuid">{39D1B51B-ECB2-4C2D-8FB0-4D1A96E1D541}</string>
										<ProtectedString name="Source"><![CDATA[local Spritesheet = require(script.Parent.Parent.Parent.Spritesheet)
local Light = {}
Light.__index = Light
setmetatable(Light, Spritesheet)

local lightTexture = "rbxassetid://408462759"

function Light.new()
    local newLight = Spritesheet.new(lightTexture)
    setmetatable(newLight, Light)
    
    newLight:AddSprite("ButtonX", Vector2.new(318, 481), Vector2.new(95, 95))    
    newLight:AddSprite("ButtonY", Vector2.new(500, 587), Vector2.new(95, 95))
    newLight:AddSprite("ButtonA", Vector2.new(308, 587), Vector2.new(95, 95))
    newLight:AddSprite("ButtonB", Vector2.new(510, 481), Vector2.new(95, 95))
    newLight:AddSprite("ButtonR1", Vector2.new(0, 416), Vector2.new(115, 64))
    newLight:AddSprite("ButtonL1", Vector2.new(116, 416), Vector2.new(115, 64))
    newLight:AddSprite("ButtonR2", Vector2.new(616, 0), Vector2.new(105, 115))
    newLight:AddSprite("ButtonL2", Vector2.new(616, 328), Vector2.new(105, 115))
    newLight:AddSprite("ButtonR3", Vector2.new(616, 550), Vector2.new(105, 105))
    newLight:AddSprite("ButtonL3", Vector2.new(616, 116), Vector2.new(105, 105))
    newLight:AddSprite("ButtonSelect", Vector2.new(404, 587), Vector2.new(95, 95))
    newLight:AddSprite("DPadLeft", Vector2.new(616, 444), Vector2.new(105, 105))
    newLight:AddSprite("DPadRight", Vector2.new(0, 587), Vector2.new(105, 105))
    newLight:AddSprite("DPadUp", Vector2.new(616, 222), Vector2.new(105, 105))
    newLight:AddSprite("DPadDown", Vector2.new(212, 481), Vector2.new(105, 105))
    newLight:AddSprite("Thumbstick1", Vector2.new(0, 481), Vector2.new(105, 105))    
    newLight:AddSprite("Thumbstick2", Vector2.new(106, 587), Vector2.new(105, 105))
    newLight:AddSprite("DPad", Vector2.new(106, 481), Vector2.new(105, 105))
    newLight:AddSprite("Controller", Vector2.new(0, 0), Vector2.new(615, 415))
    newLight:AddSprite("RotateThumbstick1", Vector2.new(414, 481), Vector2.new(95, 95))
    newLight:AddSprite("RotateThumbstick2", Vector2.new(212, 587), Vector2.new(95, 95))
    
    return newLight
end

return Light
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX0C17333A9331498F9915DB903DCDE6FC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Factory</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB09AA4F3ED7041FC9A6A4282E0FD8B99">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ButtonFactory</string>
							<string name="ScriptGuid">{E09F0BF5-6576-4F6B-8F86-BA0B3DAB710E}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

"Factory" for creating buttons. Used to be able
to set defaults once.
--]]
--!strict

local BORDER_COLOR_OFFSET = Color3.new(-30 / 255, -30 / 255, -30 / 255)



local RootModule = script.Parent.Parent

local NexusObject = require(RootModule:WaitForChild("NexusWrappedInstance"):WaitForChild("NexusInstance"):WaitForChild("NexusObject"))
local NexusButton = require(RootModule)

local ButtonFactory = NexusObject:Extend()
ButtonFactory:SetClassName("ButtonFactory")

export type ButtonFactory = {
    new: () -> ButtonFactory,
    Extend: (self: ButtonFactory) -> ButtonFactory,
    CreateDefault: (Color: Color3) -> ButtonFactory,

    Create: (self: ButtonFactory) -> NexusButton.NexusButton,
    SetDefault: (self: ButtonFactory, PropertyName: string, Property: any) -> (),
    UnsetDefault: (self: ButtonFactory, PropertyName: string) -> (),
} & NexusObject.NexusObject



--[[
Adds two Color3s.
--]]
local function AddColor3(Color1: Color3, Color2: Color3): Color3
    return Color3.new(math.clamp(Color1.R + Color2.R, 0, 1), math.clamp(Color1.G + Color2.G, 0, 1), math.clamp(Color1.B + Color2.B, 0, 1))
end



--[[
Creates a button factory with the default style.
This is used by Nexus Development projects.
--]]
function ButtonFactory.CreateDefault(Color: Color3)
    --Create the factory.
    local Factory = ButtonFactory.new()

    --Set the defaults.
    Factory:SetDefault("BackgroundColor3", Color)
    Factory:SetDefault("BorderColor3", AddColor3(Color, BORDER_COLOR_OFFSET))
    Factory:SetDefault("BorderTransparency", 0.25)

    --Return the factory.
    return Factory
end

--[[
Creates a button factory.
--]]
function ButtonFactory:__new()
    NexusObject.__new(self)
    self.Defaults = {}
end

--[[
Creates a button instance.
--]]
function ButtonFactory:Create(): NexusButton.NexusButton
    --Create the button.
    local Button = NexusButton.new()

    --Set the defaults.
    for PropertyName,PropertyValue in self.Defaults do
        (Button :: any)[PropertyName] = PropertyValue
    end

    --Return the button.
    return Button
end

--[[
Sets a default property.
--]]
function ButtonFactory:SetDefault(PropertyName: string, Property: any): ()
    self.Defaults[PropertyName] = Property
end

--[[
Unsets a default property.
--]]
function ButtonFactory:UnsetDefault(PropertyName: string): ()
    self.Defaults[PropertyName] = nil
end



return ButtonFactory :: ButtonFactory]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD75A15AE5F0845798B83580981785010">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TextButtonFactory</string>
							<string name="ScriptGuid">{958B1CA2-9280-4EEE-8613-A12F7F85051A}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

"Factory" for creating text buttons. Used to be
able to set defaults once.
--]]
--!strict

local BORDER_COLOR_OFFSET = Color3.new(-30 / 255, -30 / 255, -30 / 255)



local RootModule = script.Parent.Parent

local NexusButton = require(RootModule)
local ButtonFactory = require(RootModule:WaitForChild("Factory"):WaitForChild("ButtonFactory"))

local TextButtonFactory = ButtonFactory:Extend()
TextButtonFactory:SetClassName("TextButtonFactory")

export type TextButtonFactory = {
    new: () -> TextButtonFactory,
    Extend: (self: TextButtonFactory) -> TextButtonFactory,
    CreateDefault: (Color: Color3) -> TextButtonFactory,

    Create: (self: TextButtonFactory) -> (NexusButton.NexusButton, TextLabel),
    SetTextDefault: (self: TextButtonFactory, PropertyName: string, Property: any) -> (),
    UnsetTextDefault: (self: TextButtonFactory, PropertyName: string) -> (),
} & ButtonFactory.ButtonFactory



--[[
Adds two Color3s.
--]]
local function AddColor3(Color1: Color3, Color2: Color3): Color3
    return Color3.new(math.clamp(Color1.R + Color2.R, 0, 1), math.clamp(Color1.G + Color2.G, 0, 1), math.clamp(Color1.B + Color2.B, 0, 1))
end



--[[
Creates a text button factory with the default
style. This is used by Nexus Development projects.
--]]
function TextButtonFactory.CreateDefault(Color: Color3)
    --Create the factory.
    local Factory = TextButtonFactory.new()

    --Set the defaults.
    Factory:SetDefault("BackgroundColor3", Color)
    Factory:SetDefault("BorderColor3", AddColor3(Color, BORDER_COLOR_OFFSET))
    Factory:SetDefault("BorderTransparency", 0.25)
    Factory:SetTextDefault("Font", Enum.Font.SourceSans)
    Factory:SetTextDefault("TextColor3", Color3.new(1,1,1))
    Factory:SetTextDefault("TextStrokeColor3", Color3.new(0,0,0))
    Factory:SetTextDefault("TextStrokeTransparency", 0)
    Factory:SetTextDefault("TextScaled", true)

    --Return the factory.
    return Factory
end

--[[
Creates a text button factory.
--]]
function TextButtonFactory:__new()
    ButtonFactory.__new(self)
    self.TextDefaults = {}
end

--[[
Creates a text button instance.
--]]
function TextButtonFactory:Create()
    --Create the button.
    local Button = ButtonFactory.Create(self)

    --Add a text label.
    local TextLabel = Instance.new("TextLabel")
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    TextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
    TextLabel.BackgroundTransparency = 1
    TextLabel.ZIndex = 5
    TextLabel.Parent = Button:GetAdornFrame()

    --Set the text defaults.
    for PropertyName,PropertyValue in self.TextDefaults do
        (TextLabel :: any)[PropertyName] = PropertyValue
    end

    --Return the button and textlabel.
    return Button, TextLabel
end

--[[
Sets a default text property.
--]]
function ButtonFactory:SetTextDefault(PropertyName: string, Property: any): ()
    self.TextDefaults[PropertyName] = Property
end

--[[
Unsets a default text property.
--]]
function ButtonFactory:UnsetTextDefault(PropertyName: string): ()
    self.TextDefaults[PropertyName] = nil
end



return TextButtonFactory :: TextButtonFactory]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXBD0E714172564ABD974B52818A63F205">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ThemedFrame</string>
						<string name="ScriptGuid">{43606E3D-70A0-407D-9D8B-92D00DAEE3DF}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Frame that has the same theming for the buttons.
--]]

local NexusButton = require(script.Parent)
local NexusWrappedInstance = require(script.Parent:WaitForChild("NexusWrappedInstance"))

local ThemedFrame = NexusWrappedInstance:Extend()
ThemedFrame:SetClassName("ThemedFrame")

export type ThemedFrame = {
    new: () -> ThemedFrame,
    Extend: (self: ThemedFrame) -> ThemedFrame,

    Theme: NexusButton.NexusButtonTheme,
} & "ImageLabel"



--[[
Creates the themed frame.
--]]
function ThemedFrame:__new()
    NexusWrappedInstance.__new(self, "ImageLabel")
    self.BackgroundTransparency = 1

    --Connect replicating values.
    local ButtonPropertyOverrides = {}
    self:AddGenericPropertyFinalizer(function(PropertyName: string, Value: any)
        if not ButtonPropertyOverrides[PropertyName] then
            return
        end
        ButtonPropertyOverrides[PropertyName](Value)
    end)

    --Set the replication overrides.
    self:DisableChangeReplication("BackgroundColor3")
    ButtonPropertyOverrides["BackgroundColor3"] = function(NewBackgroundColor3: Color3)
        self.ImageColor3 = NewBackgroundColor3
    end
    self:DisableChangeReplication("BackgroundTransparency")
    ButtonPropertyOverrides["BackgroundTransparency"] = function(NewBackgroundTransparency: Color3)
        self.ImageTransparency = NewBackgroundTransparency
    end
    self:DisableChangeReplication("SliceScaleMultiplier")
    ButtonPropertyOverrides["SliceScaleMultiplier"] = function()
        self:UpdateSliceScale()
    end
    self:DisableChangeReplication("Theme")
    ButtonPropertyOverrides["Theme"] = function(NewTheme: string)
        local Theme = NexusButton.Themes[self.Theme]
        if not Theme then
            error("Unknown theme: "..tostring(NewTheme))
        end
        self.Image = Theme.MainButton.Image
        self.SliceCenter = Theme.MainButton.SliceCenter
        self:UpdateSliceScale()
    end
    self:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        self:UpdateSliceScale()
    end)

    --Set the defaults.
    self.BackgroundColor3 = Color3.new(1, 1, 1)
    self.ScaleType = Enum.ScaleType.Slice
    self.SliceScaleMultiplier = 0.5
    self.Size = UDim2.new(0, 100, 0, 100)
    self.Theme = "CutCorners"
end

--[[
Updates the slice scale of the frame.
--]]
function ThemedFrame:UpdateSliceScale(): ()
    if not self.Theme then return end
    local Theme = NexusButton.Themes[self.Theme]
    self.SliceScale = math.min(self.AbsoluteSize.X, self.AbsoluteSize.Y) * Theme.MainButton.SliceScaleMultiplier * (self.SliceScaleMultiplier or 1)
end




return ThemedFrame :: ThemedFrame]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX236C537FE84143E3989F66F4D756B79C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NexusWrappedInstance</string>
						<string name="ScriptGuid">{D18E491E-7D32-49C9-B444-459890069803}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Wraps a Roblox Instance to add additional
functionality.
--]]
--!strict

--Certain versions of Nexus Wrapped Instance have incompatibilities
--with other versions. Increment this number if a breaking change
--is made, such as Nexus Instance V.2.X.X to V.3.X.X.
local SINGLETON_COMPATIBILITY_VERSION = 2

local RunService = game:GetService("RunService")

local NexusInstance = require(script:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local NexusEvent = require(script:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusWrappedInstance = NexusInstance:Extend()
NexusWrappedInstance:SetClassName("NexusWrappedInstance")
NexusWrappedInstance.CachedInstances = {}
setmetatable(NexusWrappedInstance.CachedInstances, {__mode = "v"})

export type NexusWrappedInstance = {
    new: (InstanceType: string | Instance) -> NexusWrappedInstance,
    Extend: (self: NexusWrappedInstance) -> NexusWrappedInstance,
    CreateGetInstance: (Class: NexusWrappedInstance) -> (),

    GetWrappedInstance: (self: NexusWrappedInstance) -> Instance,
    IgnoreWrapping: (self: NexusWrappedInstance, PropertyName: string) -> (),
    DisableChangeReplication: (self: NexusWrappedInstance, PropertyName: string) -> (),
    EnableChangeReplication: (self: NexusWrappedInstance, PropertyName: string) -> (),
    ConvertProperty: (self: NexusWrappedInstance, PropertyName: string, PropertyValue: any) -> any,
} & NexusInstance.NexusInstance & Instance



--[[
Wraps the instance or table.
--]]
local function WrapData(InstanceOrTable: any): any
    --Return the wrapped object.
    if typeof(InstanceOrTable) == "Instance" then
        return NexusWrappedInstance.GetInstance(InstanceOrTable)
    end

    --Change the table entries.
    if typeof(InstanceOrTable) == "table" and not InstanceOrTable.IsA then
        for Key,Value in InstanceOrTable do
            if typeof(Value) == "Instance" or typeof(Value) == "table" then
                InstanceOrTable[Key] = WrapData(Value)
            end
        end
    end

    --Return the base value.
    return InstanceOrTable
end

--[[
Unwraps the instance or table.
--]]
local function UnwrapData(InstanceOrTable: any): any
    --Unwrap the table.
    if typeof(InstanceOrTable) == "table" then
        if InstanceOrTable.WrappedInstance then
            --Unwrap the instance.
            return InstanceOrTable.WrappedInstance
        else
            --Change the table entries.
            for Key,Value in InstanceOrTable do
                if typeof(Value) == "table" then
                    InstanceOrTable[Key] = UnwrapData(Value)
                end
            end
        end
    end

    --Return the base value.
    return InstanceOrTable
end



--[[
Creates a GetInstance method for the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusWrappedInstance:CreateGetInstance(Class: NexusWrappedInstance)
    Class = Class or self
    Class.GetInstance = function(ExistingInstance: string | Instance): NexusWrappedInstance
        --Create the string instance or create the cached instance if needed.
        local CachedInstance = NexusWrappedInstance.CachedInstances[ExistingInstance]
        if typeof(ExistingInstance) == "string" then
            CachedInstance = Class.new(ExistingInstance)
        else
            if not CachedInstance then
                CachedInstance = Class.new(ExistingInstance)
            end
        end
        
        --Return the cached entry.
        return CachedInstance
    end
end
NexusWrappedInstance:CreateGetInstance(NexusWrappedInstance)

--[[
Creates a Nexus Wrapped Instance object.
--]]
function NexusWrappedInstance:__new(InstanceOrStringToWrap: string | Instance)
    if self.WrappedInstance then return end
    NexusInstance.__new(self)

    --Convert the instance to wrap if it is a string.
    local InstanceToWrap: Instance = nil
    if typeof(InstanceOrStringToWrap) == "string" then
        InstanceToWrap = Instance.new(InstanceOrStringToWrap :: any)
    else
        InstanceToWrap = InstanceOrStringToWrap :: Instance
    end
    
    --Store the value in the cache.
    local UnwrappedProperties = {
        WrappedInstance = true,
    }
    self.CachedInstances[InstanceToWrap] = self
    self.DisabledChangesReplication = {}
    self.EventsToDisconnect = {}
    self.UnwrappedProperties = UnwrappedProperties
    self.WrappedInstance = InstanceToWrap
    self:DisableChangeReplication("EventsToDisconnect")

    --Modify indexing to get instance properties.
    local OriginalIndexFunction = getmetatable(self).__index
    getmetatable(self).__index = function(MethodObject: any, Index: string): any
        --Return the object value if it exists.
        local BaseReturn = OriginalIndexFunction(MethodObject, Index)
        if UnwrappedProperties[Index] then
            return BaseReturn
        end
        if BaseReturn ~= nil or Index == "DisabledChangesReplication" or Index == "EventsToDisconnect" then
            return WrapData(BaseReturn)
        end

        --Return nil if the replication is disabled.
        local DisabledChangesReplication = self.DisabledChangesReplication
        if DisabledChangesReplication and DisabledChangesReplication[Index] then
            return nil
        end

        --Return the wrapped object's value.
        local WrappedInstance = self.WrappedInstance
        if WrappedInstance then
            local Value = WrappedInstance[Index]

            --Wrap the event.
            if typeof(Value) == "RBXScriptSignal" then
                --Create and store the event.
                local Event = NexusEvent.new()
                self:DisableChangeReplication(Index)
                self[Index] = Event
                table.insert(self.EventsToDisconnect, Event)

                --Connect the event.
                Value:Connect(function(...)
                    local TotalArguments = select("#", ...)
                    Event:Fire(table.unpack(WrapData({...}), 1, TotalArguments))
                end)

                --Return the event.
                return Event
            end

            --Wrap the function.
            if typeof(Value) == "function" then
                --Wrap the function.
                local function WrappedFunction(...)
                    --Unwrap the parameters for the call.
                    local TotalArguments = select("#", ...)
                    local UnwrappedArguments = UnwrapData(table.pack(...))

                    --Call and return the wrapped parameters.
                    return WrapData(Value(table.unpack(UnwrappedArguments, 1, TotalArguments)))
                end

                --Store and return the function.
                self:DisableChangeReplication(Index)
                self[Index] = WrappedFunction
                return WrappedFunction
            end

            --Return the wrapped data.
            return WrapData(Value)
        end

        --Return nil (default case for typing).
        return nil
    end

    --Set up the cyclic property changing blocking.
    --Done internally to reduce overhead.
    local PreviousChanges = {}
    local PreviousChangesClearQueued = false

    --[[
    Queues clearing the previous changes.
    --]]
    local function QueueClearingChanges(): ()
        --Return if clearing is already queued.
        if PreviousChangesClearQueued then
            return
        end

        --Clear the previous changes after the next step.
        --Done to prevent storing extra data in memory that would prevent garbage collection.
        PreviousChangesClearQueued = true
        task.spawn(function()
            RunService.Heartbeat:Wait()
            PreviousChanges = {}
            PreviousChangesClearQueued = false
        end)
    end

    --Connect replicating properties.
    self:AddGenericPropertyFinalizer(function(PropertyName: string, Value: any): ()
        --Return if the replication is disabled.
        if self.DisabledChangesReplication[PropertyName] then
            return
        end

        --Return if the value is the same as the previous change in the last step.
        if PreviousChanges[PropertyName] == Value then
            return
        end

        --Add the property to the list of changed values and queue clearing the list.
        --This prevents converted values from affecting the previous set, leading to a stack overflow from the events.
        local ConvertedValue = self:ConvertProperty(PropertyName,Value)
        PreviousChanges[PropertyName] = ConvertedValue
        QueueClearingChanges();

        --Replicate the change.
        (InstanceToWrap :: any)[PropertyName] = ConvertedValue
    end)
    InstanceToWrap.Changed:Connect(function(PropertyName: string): ()
        pcall(function()
            --Return if the replication is disabled.
            if self.DisabledChangesReplication[PropertyName] then
                return
            end

            --Read the new value.
            local NewValue = (InstanceToWrap :: any)[PropertyName]

            --Return if the value is the same as the previous change in the last step.
            if PreviousChanges[PropertyName] == NewValue then
                return
            end

            --Add the property to the list of changed values and queue clearing the list.
            --This prevents converted values from affecting the previous set, leading to a stack overflow from the events.
            PreviousChanges[PropertyName] = NewValue
            QueueClearingChanges()

            --Change the property.
            local ExistingValue = self[PropertyName]
            if ExistingValue ~= nil and ExistingValue ~= NewValue then
                self[PropertyName] = NewValue
            else
                self.Changed:Fire(PropertyName)
                self:GetPropertyChangedSignal(PropertyName):Fire()
            end
        end)
    end)

    --Connect the instance being destroyed.
    --Mainly used if ClearAllChildren is called and Destroy isn't explicitly called.
    --Workaround by Corecii.
    local AncestryChangedConnection
    AncestryChangedConnection = InstanceToWrap.AncestryChanged:Connect(function()
        RunService.Heartbeat:Wait()
        if not AncestryChangedConnection.Connected then
            self:Destroy()
        end
    end)
    table.insert(self.EventsToDisconnect, AncestryChangedConnection)
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusWrappedInstance:IsA(ClassName: string): boolean
    return self:GetWrappedInstance():IsA(ClassName) or NexusInstance.IsA(self, ClassName)
end

--[[
Sets the Parent property to nil, locks the Parent
property, and calls Destroy on all children.
--]]
function NexusWrappedInstance:Destroy(): ()
    NexusInstance.Destroy(self)

    --Destroy the wrapped instance.
    local WrappedInstance = self:GetWrappedInstance()
    if WrappedInstance then
        WrappedInstance:Destroy()
    end

    --Disconnect the events.
    for _,Event in self.EventsToDisconnect do
        Event:Disconnect()
    end
    self.EventsToDisconnect = {}
end

--[[
Returns the wrapped instance.
--]]
function NexusWrappedInstance:GetWrappedInstance()
    return self.WrappedInstance
end

--[[
Makes it so a property is never wrapped.
--]]
function NexusWrappedInstance:IgnoreWrapping(PropertYName: string): ()
    self.UnwrappedProperties[PropertYName] = true
end

--[[
Disables changes being replicated to the wrapped
instance for a specific property.
--]]
function NexusWrappedInstance:DisableChangeReplication(PropertyName: string): ()
    self.DisabledChangesReplication[PropertyName] = true
end

--[[
Enables changes being replicated to the wrapped
instance for a specific property.
--]]
function NexusWrappedInstance:EnableChangeReplication(PropertyName: string): ()
    self.DisabledChangesReplication[PropertyName] = nil
end

--[[
Converts a property for replicating to the
wrapped instance.
--]]
function NexusWrappedInstance:ConvertProperty(PropertyName: string, PropertyValue: any): any
    return UnwrapData(PropertyValue)
end



--In non-test environemnts, return a singleton version of the module.
--Multiple instances of Nexus Wrapped Instance can have unintended consequences with the state being distributed and inconsistent.
if _G.EnsureNexusWrappedInstanceSingleton ~= false then
    if not _G.NexusWrappedInstanceSingletonVersions then
        _G.NexusWrappedInstanceSingletonVersions = {}
    end
    if not _G.NexusWrappedInstanceSingletonVersions[SINGLETON_COMPATIBILITY_VERSION] then
        _G.NexusWrappedInstanceSingletonVersions[SINGLETON_COMPATIBILITY_VERSION] = NexusWrappedInstance
    end
    return _G.NexusWrappedInstanceSingletonVersions[SINGLETON_COMPATIBILITY_VERSION]
end
return (NexusWrappedInstance :: any) :: NexusWrappedInstance]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX84B122D66AE74B4CACF49D8A8DD2A6BB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">NexusInstance</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX597EC422F6044032BA975B5E122C2A73">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Event</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX6EF9951EB3804B6A962601EEA7DDD1C4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">NexusConnection</string>
									<string name="ScriptGuid">{01471292-C71E-4A45-8A7C-EFF2C6D71272}</string>
									<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Represents an event connection.
--]]
--!strict

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName("NexusConnection")

export type NexusConnectionEvent<T...> = {
    Disconnected: (NexusConnectionEvent<T...>) -> (),
    [string]: any,
}
export type NexusConnection<T...> = {
    new: (Event: NexusConnectionEvent<T...>, ConnectionFunction: (T...) -> ()) -> (NexusConnection<T...>),
    Extend: (self: NexusConnection<T...>) -> (NexusConnection<T...>),

    Connected: boolean,
    Fire: (NexusConnectionEvent<T...>, T...) -> (),
    Disconnect: () -> (),
} & NexusObject.NexusObject



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new<T...>(Event: NexusConnectionEvent<T...>, ConnectionFunction): ()
    NexusObject.__new(self)
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire<T>(...: T): ()
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect(): ()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection :: NexusConnection<>]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4B8F5DA0ECD048B3B49833499E590A76">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">NexusEvent</string>
									<string name="ScriptGuid">{27531302-7EC9-48CF-948A-E8F56291D8A0}</string>
									<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Sends and listens to events.
--]]
--!strict

local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local NexusEvent = NexusObject:Extend()
NexusEvent:SetClassName("NexusEvent")

export type NexusEvent<T...> = {
    new: () -> (NexusEvent<T...>),
    Extend: (self: NexusEvent<T...>) -> (NexusEvent<T...>),

    Connect: (self: NexusEvent<T...>, Callback: (T...) -> ()) -> (NexusConnection.NexusConnection<T...>),
    Fire: (self: NexusEvent<T...>, T...) -> (),
    Disconnect: (self: NexusEvent<T...>) -> (),
} & NexusObject.NexusObject



--[[
Creates an event.
--]]
function NexusEvent:__new(): ()
    NexusObject.__new(self)
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")
    self.CurrentWaits = 0

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments, {__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function NexusEvent:Disconnected<T...>(Connection: NexusConnection.NexusConnection<T...>): ()
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function NexusEvent:Disconnect(): ()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection, _ in self.Connections do
        table.insert(ConnectionsToDisconnect, Connection)
    end
    
    --Disconnect the events.
    for _, Connection in ConnectionsToDisconnect do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function NexusEvent:Connect<T...>(Callback: (T...) -> ()): NexusConnection.NexusConnection<T...>
    --Create the connection.
    local Connection = NexusConnection.new(self, Callback :: any)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[UUID] = nil

        --Fire the event.
        Connection:Fire(table.unpack(Arguments))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Fires the event.
--]]
function NexusEvent:Fire<T>(...: T): ()
    --Ignore if there are no connections.
    --If continued, self.LastArgumentsStrong will be populated and never cleared, leading to a memory leak.
    if next(self.Connections) == nil and self.CurrentWaits <= 0 then return end

    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function NexusEvent:Wait<T>(): (T)
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[UUID] = nil
    return table.unpack(Arguments)
end



return NexusEvent :: NexusEvent<>]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX0C3BE641BCE34E82981F1023CF92C39C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NexusInstance</string>
								<string name="ScriptGuid">{449A4D7C-B323-49FB-A0FC-FB2F58814AA8}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]
--!strict

local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName("NexusInstance")

export type LegacyPropertyValidator = {
    ValidateChange: (self: LegacyPropertyValidator, Object: NexusInstance, Index: string, Value: any) -> (any),
}
export type NexusInstance = {
    new: () -> (NexusInstance),
    Extend: (self: NexusInstance) -> (NexusInstance),

    Changed: NexusEvent.NexusEvent<string>,
    AddGenericPropertyValidator: (self: NexusInstance, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddPropertyValidator: (self: NexusInstance, PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddGenericPropertyFinalizer: (self: NexusInstance, Finalizer: (string, any) -> ()) -> (),
    AddPropertyFinalizer: (self: NexusInstance, PropertyName: string, Finalizer: (string, any) -> ()) -> (),
    LockProperty: (self: NexusInstance, PropertyName: string) -> (),
    HidePropertyChanges: (self: NexusInstance, PropertyName: string) -> (),
    HideNextPropertyChange: (self: NexusInstance, PropertyName: string) -> (),
    GetPropertyChangedSignal: (self: NexusInstance, PropertyName: string) -> (NexusEvent.NexusEvent<>),
    Destroy: (self: NexusInstance) -> (),
} & NexusObject.NexusObject



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new(): ()
    --Set up the base object.
    NexusObject.__new(self)

    --Set up the internal properties.
    self:__InitInternalProperties()
    self:__InitMetaMethods()
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties(): ()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEvent.new()
    self.Changed = self.__ChangedEvent

    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods(): ()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent

    --Set up custom indexing.
    local Metatable = {}
    local OriginalIndexTable = getmetatable(self).__index
    setmetatable(self, Metatable)
    Metatable.__index = function(_, Index: string): any
        --Return the internal property.
        local InternalPropertyValue = InternalProperties[Index]
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end

        --Return the base return.
        return OriginalIndexTable[Index]
    end

    --Set up changes.
    Metatable.__newindex = function(_, Index: string, Value: any): ()
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end

        --Return if the new and old values are the same.
        if self[Index] == Value then
            return
        end

        --Validate the value.
        for _,Validator in GenericPropertyValidators do
            Value = Validator(Index, Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _, Validator in Validators do
                Value = Validator(Index, Value)
            end
        end

        --Change the property.
        InternalProperties[Index] = Value

        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _, Finalizer in GenericPropertyFinalizers do
            Finalizer(Index, Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _, Finalizer in Finalizers do
                Finalizer(Index, Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end

        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end

        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddGenericPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddGenericPropertyValidator(function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    table.insert(self.__GenericPropertyValidators, Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddPropertyValidator(PropertyName, function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName], Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer: (string, any) -> ()): ()
    table.insert(self.__GenericPropertyFinalizers, Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName: string, Finalizer: (string, any) -> ())
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName], Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName: string): ()
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName: string): ()
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName: string): ()
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName: string): NexusEvent.NexusEvent<>
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEvent.new()
    end

    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in self.__PropertyChanged do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance :: NexusInstance]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF4F5633523B44AECAF9B898080BF59B6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NexusObject</string>
								<string name="ScriptGuid">{FFDB2636-912D-4883-B14C-0BE7F061A70F}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table: any): string
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil

    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    return String
end

--[[
Extends a class.
--]]
local function ExtendClass(SuperClass: {[string]: any}?) : NexusObject
    --Create the class.
    local Class = {}
    Class.super = SuperClass
    Class.__index = Class
    setmetatable(Class :: any, SuperClass)

    --[[
    Creates an object.
    --]]
    function Class.new(...)
        --Create the base object.
        local self = {} :: NexusObject
        self.__index = self
        self.class = Class
        setmetatable(self :: any, Class)

        --Run the constructor.
        self:__new(...)

        --Return the object.
        return self
    end

    --[[
    Constructor run for the class.
    --]]    
    function Class:__new(...)
        if not SuperClass then return end
        (SuperClass :: NexusObject).__new(self, ...)
    end

    --Add the metamethod passthrough.
    if SuperClass then
        for _, MetatableName in METATABLE_METHODS do
            Class[MetatableName] = SuperClass[MetatableName]
        end
    end

    --Call the callback for the class being extended.
    if SuperClass then
        SuperClass:__classextended(Class)
    end

    --Return the created class.
    return (Class :: any) :: NexusObject
end



--Set up the base Nexus Object class.
local NexusObject = ExtendClass() :: NexusObject
NexusObject.ClassName = "NexusObject"

export type NexusObject = {
    --Properties.
    class: {[string]: any},
    super: NexusObject,
    ClassName: string,
    [string]: any,

    --Static methods.
    new: () -> (NexusObject),
    Extend: (self: NexusObject) -> (NexusObject),
    SetClassName: (self: NexusObject, ClassName: string) -> (NexusObject),

    --Methods.
    IsA: (self: NexusObject, ClassName: string) -> (boolean),
}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass: NexusObject): ()
    if not self.super then return end
    self.super:__classextended(OtherClass)
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring(): string
    local MemoryAddress = string.sub(RawToString(self), 8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject: any): boolean
    return rawequal(self, OtherObject)
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName: string): NexusObject
    self.ClassName = ClassName
    return self
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend(): NexusObject
    return (ExtendClass(self) :: any) :: NexusObject
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName: string): boolean
    --If the class name matches the class name, return true.
    local CurrentClass = self
    while CurrentClass do
        if CurrentClass.ClassName == ClassName then
            return true
        end
        CurrentClass = CurrentClass.super
    end

    --Return false (no match).
    return false
end



return NexusObject]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX019B4224478442778701CA3845D68B31">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">PropertyValidator</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX79F43326E2D240959778A3A5419F25F1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TypePropertyValidator</string>
									<string name="ScriptGuid">{BDAE7FDE-4F93-4C24-A47B-51F566BB5A12}</string>
									<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName("TypePropertyValidator")

export type TypePropertyValidator = {
    CreateTypeValidator: (Type: string) -> ((string, any) -> (any)),
    new: (Type: string) -> (TypePropertyValidator),
    Extend: (self: TypePropertyValidator) -> (TypePropertyValidator),

    ValidateChange: (self: TypePropertyValidator, Object: any, ValueName: string, Value: any) -> (any),
} & NexusObject.NexusObject



--[[
Creates a type validator for a type.
--]]
function TypePropertyValidator.CreateTypeValidator(Type: string): (string, any) -> (any)
    return function(ValueName: string, Value: any): any
        --Determine the type.
        local TypeMatches, ClassMatches = false, false
        local ValueType = typeof(Value)

        --Determine if the type matchs.
        if ValueType == Type then
            TypeMatches = true
        end

        --Determine if the class name matches.
        if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
            ValueType = Value.ClassName
            if Value:IsA(Type) then
                ClassMatches = true
            end
        end

        --Throw an error if the type is invalid.
        if not TypeMatches and not ClassMatches then
            error("Bad value for \""..tostring(ValueName).."\" ("..tostring(Type).." expected, got "..ValueType..")")
        end

        --Return the original value.
        return Value
    end
end

--[[
Creates a type validator.
--]]
function TypePropertyValidator:__new(Type: string): ()
    warn("TypePropertyValidator.new() is deprecated with object-based validators. Use CreateTypeValidator(Type) instead.")
    NexusObject.__new(self)
    self.Validator = TypePropertyValidator.CreateTypeValidator(Type)
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object: any, ValueName: string, Value: any)
    return self.Validator(ValueName, Value)
end



return TypePropertyValidator :: TypePropertyValidator]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD8D726664F184B68B2122044CFBECFE9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">NexusInstance</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX99263DA727354062A5AD2B81569A298E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Event</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8755DBDA380C46F3861DA2FA3F546B92">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NexusConnection</string>
							<string name="ScriptGuid">{C07C75D5-A333-4815-ABDA-AB371BC16A41}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Represents an event connection.
--]]
--!strict

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName("NexusConnection")

export type NexusConnectionEvent<T...> = {
    Disconnected: (NexusConnectionEvent<T...>) -> (),
    [string]: any,
}
export type NexusConnection<T...> = {
    new: (Event: NexusConnectionEvent<T...>, ConnectionFunction: (T...) -> ()) -> (NexusConnection<T...>),
    Extend: (self: NexusConnection<T...>) -> (NexusConnection<T...>),

    Connected: boolean,
    Fire: (NexusConnectionEvent<T...>, T...) -> (),
    Disconnect: () -> (),
} & NexusObject.NexusObject



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new<T...>(Event: NexusConnectionEvent<T...>, ConnectionFunction): ()
    NexusObject.__new(self)
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire<T>(...: T): ()
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect(): ()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection :: NexusConnection<>]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2C90850E37184592A7EFF050D59C2BF0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NexusEvent</string>
							<string name="ScriptGuid">{A51138F0-3BFC-467C-AC52-66B91DF1C2B0}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Sends and listens to events.
--]]
--!strict

local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local NexusEvent = NexusObject:Extend()
NexusEvent:SetClassName("NexusEvent")

export type NexusEvent<T...> = {
    new: () -> (NexusEvent<T...>),
    Extend: (self: NexusEvent<T...>) -> (NexusEvent<T...>),

    Connect: (self: NexusEvent<T...>, Callback: (T...) -> ()) -> (NexusConnection.NexusConnection<T...>),
    Fire: (self: NexusEvent<T...>, T...) -> (),
    Disconnect: (self: NexusEvent<T...>) -> (),
} & NexusObject.NexusObject



--[[
Creates an event.
--]]
function NexusEvent:__new(): ()
    NexusObject.__new(self)
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")
    self.CurrentWaits = 0

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments, {__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function NexusEvent:Disconnected<T...>(Connection: NexusConnection.NexusConnection<T...>): ()
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function NexusEvent:Disconnect(): ()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection, _ in self.Connections do
        table.insert(ConnectionsToDisconnect, Connection)
    end
    
    --Disconnect the events.
    for _, Connection in ConnectionsToDisconnect do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function NexusEvent:Connect<T...>(Callback: (T...) -> ()): NexusConnection.NexusConnection<T...>
    --Create the connection.
    local Connection = NexusConnection.new(self, Callback :: any)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[UUID] = nil

        --Fire the event.
        Connection:Fire(table.unpack(Arguments))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Fires the event.
--]]
function NexusEvent:Fire<T>(...: T): ()
    --Ignore if there are no connections.
    --If continued, self.LastArgumentsStrong will be populated and never cleared, leading to a memory leak.
    if next(self.Connections) == nil and self.CurrentWaits <= 0 then return end

    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function NexusEvent:Wait<T>(): (T)
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[UUID] = nil
    return table.unpack(Arguments)
end



return NexusEvent :: NexusEvent<>]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX9ADC3DDB24A94B14A7C78AD918DD3BA0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NexusInstance</string>
						<string name="ScriptGuid">{763FA225-14E0-4E8C-9BB4-8BB24BF8012A}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]
--!strict

local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName("NexusInstance")

export type LegacyPropertyValidator = {
    ValidateChange: (self: LegacyPropertyValidator, Object: NexusInstance, Index: string, Value: any) -> (any),
}
export type NexusInstance = {
    new: () -> (NexusInstance),
    Extend: (self: NexusInstance) -> (NexusInstance),

    Changed: NexusEvent.NexusEvent<string>,
    AddGenericPropertyValidator: (self: NexusInstance, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddPropertyValidator: (self: NexusInstance, PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddGenericPropertyFinalizer: (self: NexusInstance, Finalizer: (string, any) -> ()) -> (),
    AddPropertyFinalizer: (self: NexusInstance, PropertyName: string, Finalizer: (string, any) -> ()) -> (),
    LockProperty: (self: NexusInstance, PropertyName: string) -> (),
    HidePropertyChanges: (self: NexusInstance, PropertyName: string) -> (),
    HideNextPropertyChange: (self: NexusInstance, PropertyName: string) -> (),
    GetPropertyChangedSignal: (self: NexusInstance, PropertyName: string) -> (NexusEvent.NexusEvent<>),
    Destroy: (self: NexusInstance) -> (),
} & NexusObject.NexusObject



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new(): ()
    --Set up the base object.
    NexusObject.__new(self)

    --Set up the internal properties.
    self:__InitInternalProperties()
    self:__InitMetaMethods()
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties(): ()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEvent.new()
    self.Changed = self.__ChangedEvent

    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods(): ()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent

    --Set up custom indexing.
    local Metatable = {}
    local OriginalIndexTable = getmetatable(self).__index
    setmetatable(self, Metatable)
    Metatable.__index = function(_, Index: string): any
        --Return the internal property.
        local InternalPropertyValue = InternalProperties[Index]
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end

        --Return the base return.
        return OriginalIndexTable[Index]
    end

    --Set up changes.
    Metatable.__newindex = function(_, Index: string, Value: any): ()
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end

        --Return if the new and old values are the same.
        if self[Index] == Value then
            return
        end

        --Validate the value.
        for _,Validator in GenericPropertyValidators do
            Value = Validator(Index, Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _, Validator in Validators do
                Value = Validator(Index, Value)
            end
        end

        --Change the property.
        InternalProperties[Index] = Value

        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _, Finalizer in GenericPropertyFinalizers do
            Finalizer(Index, Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _, Finalizer in Finalizers do
                Finalizer(Index, Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end

        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end

        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddGenericPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddGenericPropertyValidator(function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    table.insert(self.__GenericPropertyValidators, Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddPropertyValidator(PropertyName, function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName], Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer: (string, any) -> ()): ()
    table.insert(self.__GenericPropertyFinalizers, Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName: string, Finalizer: (string, any) -> ())
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName], Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName: string): ()
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName: string): ()
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName: string): ()
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName: string): NexusEvent.NexusEvent<>
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEvent.new()
    end

    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in self.__PropertyChanged do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance :: NexusInstance]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6C7AB62318B54D95BC5DFC3AAA3153DC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NexusObject</string>
						<string name="ScriptGuid">{960EEA05-5B09-44EF-BFF4-FCBF87774067}</string>
						<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table: any): string
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil

    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    return String
end

--[[
Extends a class.
--]]
local function ExtendClass(SuperClass: {[string]: any}?) : NexusObject
    --Create the class.
    local Class = {}
    Class.super = SuperClass
    Class.__index = Class
    setmetatable(Class :: any, SuperClass)

    --[[
    Creates an object.
    --]]
    function Class.new(...)
        --Create the base object.
        local self = {} :: NexusObject
        self.__index = self
        self.class = Class
        setmetatable(self :: any, Class)

        --Run the constructor.
        self:__new(...)

        --Return the object.
        return self
    end

    --[[
    Constructor run for the class.
    --]]    
    function Class:__new(...)
        if not SuperClass then return end
        (SuperClass :: NexusObject).__new(self, ...)
    end

    --Add the metamethod passthrough.
    if SuperClass then
        for _, MetatableName in METATABLE_METHODS do
            Class[MetatableName] = SuperClass[MetatableName]
        end
    end

    --Call the callback for the class being extended.
    if SuperClass then
        SuperClass:__classextended(Class)
    end

    --Return the created class.
    return (Class :: any) :: NexusObject
end



--Set up the base Nexus Object class.
local NexusObject = ExtendClass() :: NexusObject
NexusObject.ClassName = "NexusObject"

export type NexusObject = {
    --Properties.
    class: {[string]: any},
    super: NexusObject,
    ClassName: string,
    [string]: any,

    --Static methods.
    new: () -> (NexusObject),
    Extend: (self: NexusObject) -> (NexusObject),
    SetClassName: (self: NexusObject, ClassName: string) -> (NexusObject),

    --Methods.
    IsA: (self: NexusObject, ClassName: string) -> (boolean),
}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass: NexusObject): ()
    if not self.super then return end
    self.super:__classextended(OtherClass)
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring(): string
    local MemoryAddress = string.sub(RawToString(self), 8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject: any): boolean
    return rawequal(self, OtherObject)
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName: string): NexusObject
    self.ClassName = ClassName
    return self
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend(): NexusObject
    return (ExtendClass(self) :: any) :: NexusObject
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName: string): boolean
    --If the class name matches the class name, return true.
    local CurrentClass = self
    while CurrentClass do
        if CurrentClass.ClassName == ClassName then
            return true
        end
        CurrentClass = CurrentClass.super
    end

    --Return false (no match).
    return false
end



return NexusObject]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX1086740E02DB4FE2A88B1ABA2214B160">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">PropertyValidator</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX12C7A6A154BA4B18921E350DB1658CCE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TypePropertyValidator</string>
							<string name="ScriptGuid">{3EE41BB8-5A84-4C2E-A21B-EE5BD155134A}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName("TypePropertyValidator")

export type TypePropertyValidator = {
    CreateTypeValidator: (Type: string) -> ((string, any) -> (any)),
    new: (Type: string) -> (TypePropertyValidator),
    Extend: (self: TypePropertyValidator) -> (TypePropertyValidator),

    ValidateChange: (self: TypePropertyValidator, Object: any, ValueName: string, Value: any) -> (any),
} & NexusObject.NexusObject



--[[
Creates a type validator for a type.
--]]
function TypePropertyValidator.CreateTypeValidator(Type: string): (string, any) -> (any)
    return function(ValueName: string, Value: any): any
        --Determine the type.
        local TypeMatches, ClassMatches = false, false
        local ValueType = typeof(Value)

        --Determine if the type matchs.
        if ValueType == Type then
            TypeMatches = true
        end

        --Determine if the class name matches.
        if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
            ValueType = Value.ClassName
            if Value:IsA(Type) then
                ClassMatches = true
            end
        end

        --Throw an error if the type is invalid.
        if not TypeMatches and not ClassMatches then
            error("Bad value for \""..tostring(ValueName).."\" ("..tostring(Type).." expected, got "..ValueType..")")
        end

        --Return the original value.
        return Value
    end
end

--[[
Creates a type validator.
--]]
function TypePropertyValidator:__new(Type: string): ()
    warn("TypePropertyValidator.new() is deprecated with object-based validators. Use CreateTypeValidator(Type) instead.")
    NexusObject.__new(self)
    self.Validator = TypePropertyValidator.CreateTypeValidator(Type)
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object: any, ValueName: string, Value: any)
    return self.Validator(ValueName, Value)
end



return TypePropertyValidator :: TypePropertyValidator]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXE6C53E7E732840059677A539902C580D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NexusVRCore</string>
					<string name="ScriptGuid">{5A50AA2D-C4D8-4D9D-8429-CAB4111A6EDB}</string>
					<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Project for fetching resources of Nexus VR Core.
--]]

local NexusProject = {}



--[[
Returns a resource in Nexus VR Core.
Legacy from Nexus Project.
--]]
function NexusProject:GetResource(Path: string): any
    local Module = script
    for _, PathPart in string.split(Path, ".") do
        Module = (Module :: any)[PathPart]
    end
    return require(Module :: ModuleScript)
end



return NexusProject]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX65B58842C1844EA8A0058AFF5CE4EA32">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Container</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX716B0A9F2B304BCB84547A9A687508DC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseScreenGui</string>
							<string name="ScriptGuid">{AD30991E-4A8C-44A6-AC96-19909CF3146E}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Base ScreenGui instance.
--]]
--!strict

local NexusInstance = require(script.Parent.Parent:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))

local BaseScreenGui = NexusInstance:Extend()
BaseScreenGui:SetClassName("BaseScreenGui")

export type BaseScreenGui = {
    new: (Container: LayerCollector) -> BaseScreenGui,
    Extend: (self: BaseScreenGui) -> BaseScreenGui,

    RotationOffset: CFrame,
    Depth: number,
    FieldOfView: number,
    CanvasSize: Vector2,
    Easing: number,
    PointingEnabled: boolean,
    GetContainer: (self: BaseScreenGui) -> (LayerCollector),
    DisableChangeReplication: (self: BaseScreenGui, Name: string) -> (),
    Destroy: (self: BaseScreenGui) -> (),
} & NexusInstance.NexusInstance & LayerCollector



--[[
Creates the Base ScreenGui.
--]]
function BaseScreenGui:__new(Container: LayerCollector): ()
    NexusInstance.__new(self)
    self.Container = Container

    --Set the metatables.
    local NonReplicatedProperties = {} :: {[string]: boolean}
    self.NonReplicatedProperties = NonReplicatedProperties
    local Metatable = getmetatable(self)
    local BaseIndex, BaseNewIndex = Metatable.__index, Metatable.__newindex
    Metatable.__index = function(self, Index: string): any
        local BaseReturn = BaseIndex(self, Index)
        if BaseReturn ~= nil or NonReplicatedProperties[Index] then
            return BaseReturn
        end
        return (Container :: any)[Index]
    end
    Metatable.__newindex = function(self, Index: string, Value): ()
        BaseNewIndex(self, Index, Value)
        if not NonReplicatedProperties[Index] then
            (Container :: any)[Index] = Value
        end
    end

    --Set the properties.
    self:DisableChangeReplication("RotationOffset")
    self.RotationOffset = CFrame.new()
    self:DisableChangeReplication("Depth")
    self.Depth = 5
    self:DisableChangeReplication("FieldOfView")
    self.FieldOfView = math.rad(50)
    if not Container:IsA("SurfaceGui") then
        self:DisableChangeReplication("CanvasSize")
    end
    self.CanvasSize = Vector2.new(1000, 1000)
    self:DisableChangeReplication("Easing")
    self.Easing = 0
    self:DisableChangeReplication("PointingEnabled")
    self.PointingEnabled = true
end

--[[
Disables a change to replicate to the container.
--]]
function BaseScreenGui:DisableChangeReplication(Name: string)
    self.NonReplicatedProperties[Name] = true
end

--[[
Returns the container of the ScreenGui.
--]]
function BaseScreenGui:GetContainer(): LayerCollector
    return self.Container
end

--[[
Destroys the ScreenGui.
--]]
function BaseScreenGui:Destroy(): ()
    NexusInstance.Destroy(self)
    self.Container:Destroy()
end



return (BaseScreenGui :: any) :: BaseScreenGui]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6DFDE41C406F48FCA21607048F20DE53">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScreenGui</string>
							<string name="ScriptGuid">{41E12189-A18D-4B12-A019-75385159A8CB}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Contains user interface components.
--]]
--!strict

local UserInputService = game:GetService("UserInputService")

local ScreenGui3D = require(script.Parent:WaitForChild("ScreenGui3D"))
local ScreenGui2D = require(script.Parent:WaitForChild("ScreenGui2D"))



--Return the class depending on if VR is enabled or not.
if UserInputService.VREnabled then
    return ScreenGui3D
else
    return ScreenGui2D
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX131E8B77A6DE4168BA6A503427305848">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScreenGui2D</string>
							<string name="ScriptGuid">{445F7EF0-18D4-4570-A88C-6913AE28F3A4}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Implementation of a ScreenGui for 2D players.
--]]
--!strict

local BaseScreenGui = require(script.Parent:WaitForChild("BaseScreenGui"))

local ScreenGui2D = BaseScreenGui:Extend()
ScreenGui2D:SetClassName("ScreenGui2D")

export type ScreenGui2D = {
    new: () -> ScreenGui2D,
    Extend: (self: ScreenGui2D) -> ScreenGui2D,
} & BaseScreenGui.BaseScreenGui



--[[
Creates a 2D ScreenGui.
--]]
function ScreenGui2D:__new(): ()
    BaseScreenGui.__new(self, Instance.new("ScreenGui"))
end



return ScreenGui2D]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX30F71ED4AA7B4ADBA68486F6E83249A8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScreenGui3D</string>
							<string name="ScriptGuid">{ACDD02F5-E89A-42E7-AD00-F6E36926D922}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Contains user interface components for a 3D user interface.
--]]
--!strict

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local BaseScreenGui = require(script.Parent:WaitForChild("BaseScreenGui"))

local ScreenGui3D = BaseScreenGui:Extend()
ScreenGui3D:SetClassName("ScreenGui3D")

export type ScreenGui3D = {
    new: () -> ScreenGui3D,
    Extend: (self: ScreenGui3D) -> ScreenGui3D,
} & BaseScreenGui.BaseScreenGui



--[[
Creates a 3D ScreenGui.
--]]
function ScreenGui3D:__new()
    BaseScreenGui.__new(self, Instance.new("SurfaceGui"))

    --Create the Adornee.
    local NexusVRCoreContainer = Workspace.CurrentCamera:FindFirstChild("NexusVRCoreContainer")
    if not NexusVRCoreContainer then
        NexusVRCoreContainer = Instance.new("Folder")
        NexusVRCoreContainer.Name = "NexusVRCoreContainer"
        NexusVRCoreContainer.Parent = Workspace.CurrentCamera
    end
    local Adornee = Instance.new("Part")
    Adornee.Transparency = 1
    Adornee.Anchored = true
    Adornee.CanCollide = false
    Adornee.Parent = NexusVRCoreContainer
    self.Adornee = Adornee
    self.Face = Enum.NormalId.Back

    --Set the properties.
    self.AlwaysOnTop = true
    self:AddPropertyFinalizer("PointingEnabled", function()
        self.Adornee.CanQuery = self.Enabled and self.PointingEnabled
    end)
    self:AddPropertyFinalizer("Enabled", function()
        self.Adornee.CanQuery = self.Enabled and self.PointingEnabled
    end)

    --Disable replication of ScreenGui properties.
    self:DisableChangeReplication("DisplayOrder")
    self:DisableChangeReplication("IgnoreGuiInset")
    self:DisableChangeReplication("LastRotation")
    self.LastRotation = CFrame.new(Workspace.CurrentCamera:GetRenderCFrame().Position):Inverse() * Workspace.CurrentCamera:GetRenderCFrame()

    --Connect updating the size.
    self:AddPropertyFinalizer("Depth", function()
        self:UpdateSize()
    end)
    self:AddPropertyFinalizer("FieldOfView", function()
        self:UpdateSize()
    end)
    self:AddPropertyFinalizer("CanvasSize", function(Value)
        self:UpdateSize()
    end)

    --Update the size and position.
    self:UpdateSize()
    self:DisableChangeReplication("UpdateEvent")
    self.UpdateEvent = RunService.RenderStepped:Connect(function(DeltaTime: number)
        if self.Enabled then
            self:UpdateCFrame(DeltaTime)
        end
    end)
end

--[[
Updates the size of the part.
--]]
function ScreenGui3D:UpdateSize(): ()
    local Width = 2 * math.tan(self.FieldOfView/2) * self.Depth
    if self.CanvasSize.Y <= self.CanvasSize.X then
        self.Adornee.Size = Vector3.new(Width, Width * (self.CanvasSize.Y / self.CanvasSize.X), 0)
    else
        self.Adornee.Size = Vector3.new(Width * (self.CanvasSize.X / self.CanvasSize.Y), Width, 0)
    end
    self.CanvasSize = self.CanvasSize
end

--[[
Updates the CFrame of the part.
--]]
function ScreenGui3D:UpdateCFrame(DeltaTime: number): ()
    DeltaTime = DeltaTime or self.Easing

    --Update the rotation.
    local CameraCFrame = Workspace.CurrentCamera:GetRenderCFrame()
    local TargetCFrame = CFrame.new(CameraCFrame.Position):Inverse() * CameraCFrame
    if self.Easing == 0 then
        self.LastRotation = TargetCFrame
    else
        self.LastRotation = self.LastRotation:Lerp(TargetCFrame, DeltaTime / self.Easing)
    end

    --Set the CFrame.
    self.Adornee.CFrame = CFrame.new(CameraCFrame.Position) * self.LastRotation * self.RotationOffset * CFrame.new(0,0,-self.Depth)
end

--[[
Destroys the ScreenGui.
--]]
function ScreenGui3D:Destroy(): ()
    BaseScreenGui.Destroy(self)
    self.UpdateEvent:Disconnect()
    self.Adornee:Destroy()
end



return ScreenGui3D]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXB13C18E594BA449FB8AFBB27866D32FA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Utility</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX28EBEA2575FF426CB602C91892B3A9FB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PartUtility</string>
							<string name="ScriptGuid">{EA125492-770B-4737-BE84-C46EB2C04AE4}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Utility for parts.
--]]

local PartUtility = {}



--[[
Helper function for ray casting.
--]]
function PartUtility.RaycastToFront(AimingCFrame: CFrame, Size: Vector3, FrontCFrame: CFrame): (number, number, number)
    FrontCFrame = FrontCFrame * CFrame.new(0, 0, -Size.Z / 2)

    --Convert the aiming CFrame to a local CFrame.
	local LocalTargetCFrame = FrontCFrame:Inverse() * AimingCFrame
	local LocalTarget = LocalTargetCFrame.LookVector
	
	--Determine the angle away from the normal and cast the ray to the plane.
	local LookAngle = math.atan2(((LocalTarget.X ^ 2) + (LocalTarget.Y ^ 2)) ^ 0.5, LocalTarget.Z)
	local DistanceToScreen = LocalTargetCFrame.Z / math.cos(LookAngle)
	local LocalHitPosition = (LocalTargetCFrame * CFrame.new(0, 0, DistanceToScreen)).Position
	
	--Determine and return the relative positions.
	local RelativeX = 1 - (0.5 + (LocalHitPosition.X / Size.X))
	local RelativeY = 1 - (0.5 + (LocalHitPosition.Y / Size.Y))
    local Depth = -LocalTargetCFrame.Z * (1 / LocalTarget.Z)
	return RelativeX, RelativeY, Depth
end

--[[
Helper function for projecting.
--]]
function PartUtility.ProjectToFront(Position: Vector3, Size: Vector3, FrontCFrame: CFrame): (number, number, number)
    FrontCFrame = FrontCFrame * CFrame.new(0, 0, -Size.Z / 2)
	
	--Convert the aiming CFrame to a local CFrame.
	local LocalTargetCFrame = FrontCFrame:Inverse() * CFrame.new(Position)
	
	--Determine and return the relative positions.
	local RelativeX = 1 - (0.5 + (LocalTargetCFrame.X / Size.X))
	local RelativeY = 1 - (0.5 + (LocalTargetCFrame.Y / Size.Y))
	local Depth = -LocalTargetCFrame.Z
	return RelativeX, RelativeY, Depth
end

--[[
Ray casts to a surface. Returns the relative X and Y position
of the face, and the Z for the direction (>0 is facing, <0
is not facing).
--]]
function PartUtility.Raycast(Part: BasePart, AimingCFrame: CFrame, Face: Enum.NormalId | string): (number, number, number)
    local Size = Part.Size
    if Face == Enum.NormalId.Front or Face == "Front" then
        return PartUtility.RaycastToFront(AimingCFrame, Size, Part.CFrame)
    elseif Face == Enum.NormalId.Back or Face == "Back" then
        return PartUtility.RaycastToFront(AimingCFrame, Size, Part.CFrame * CFrame.Angles(0, math.pi, 0))
    elseif Face == Enum.NormalId.Top or Face == "Top" then
        local RelativeX, RelativeY, Depth = PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(math.pi / 2, 0, 0))
        return 1 - RelativeX, RelativeY, Depth
    elseif Face == Enum.NormalId.Bottom or Face == "Bottom" then
        local RelativeX, RelativeY, Depth = PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(-math.pi / 2, 0, 0))
        return RelativeX, 1 - RelativeY, Depth
    elseif Face == Enum.NormalId.Left or Face == "Left" then
        return PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, math.pi / 2, 0))
    elseif Face == Enum.NormalId.Right or Face == "Right" then
        return PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, -math.pi / 2, 0))
    end
    error("Unknown face type: "..tostring(Face))
end

--[[
Returns the relative position that is projected onto the
plane. Returns the relative X and Y position of the face,
and the Z for the direction (>0 is before the plane, <0
is after the plane).
--]]
function PartUtility.Project(Part: BasePart, HandPosition: Vector3, Face: Enum.NormalId | string): (number, number, number)
    local Size = Part.Size
    if Face == Enum.NormalId.Front or Face == "Front" then
        return PartUtility.ProjectToFront(HandPosition, Size, Part.CFrame)
    elseif Face == Enum.NormalId.Back or Face == "Back" then
        return PartUtility.ProjectToFront(HandPosition, Size, Part.CFrame * CFrame.Angles(0, math.pi, 0))
    elseif Face == Enum.NormalId.Top or Face == "Top" then
        local RelativeX, RelativeY, Depth = PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(math.pi / 2, 0, 0))
        return 1 - RelativeX, RelativeY, Depth
    elseif Face == Enum.NormalId.Bottom or Face == "Bottom" then
        local RelativeX, RelativeY, Depth = PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(-math.pi / 2, 0, 0))
        return RelativeX, 1 - RelativeY, Depth
    elseif Face == Enum.NormalId.Left or Face == "Left" then
        return PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, math.pi / 2, 0))
    elseif Face == Enum.NormalId.Right or Face == "Right" then
        return PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, -math.pi / 2, 0))
    end
    error("Unknown face type: "..tostring(Face))
end



return PartUtility]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX07BC8D692263480CB0EA38B8D5D5FFA6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">NexusInstance</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX15E072B6652E4FCBB8F32A4926B528DA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Event</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXEFC420E71C4745C78C05440A2AC9872D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NexusConnection</string>
								<string name="ScriptGuid">{67D43BFB-B6D2-4678-9178-998A333FC7C5}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Represents an event connection.
--]]
--!strict

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName("NexusConnection")

export type NexusConnectionEvent<T...> = {
    Disconnected: (NexusConnectionEvent<T...>) -> (),
    [string]: any,
}
export type NexusConnection<T...> = {
    new: (Event: NexusConnectionEvent<T...>, ConnectionFunction: (T...) -> ()) -> (NexusConnection<T...>),
    Extend: (self: NexusConnection<T...>) -> (NexusConnection<T...>),

    Connected: boolean,
    Fire: (NexusConnectionEvent<T...>, T...) -> (),
    Disconnect: () -> (),
} & NexusObject.NexusObject



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new<T...>(Event: NexusConnectionEvent<T...>, ConnectionFunction): ()
    NexusObject.__new(self)
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire<T>(...: T): ()
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect(): ()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection :: NexusConnection<>]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX46C50F2FE06042348A8A25ABBC0F59E7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NexusEvent</string>
								<string name="ScriptGuid">{FEF6749E-2D77-4737-913B-387F0FBEC37D}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Sends and listens to events.
--]]
--!strict

local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local NexusEvent = NexusObject:Extend()
NexusEvent:SetClassName("NexusEvent")

export type NexusEvent<T...> = {
    new: () -> (NexusEvent<T...>),
    Extend: (self: NexusEvent<T...>) -> (NexusEvent<T...>),

    Connect: (self: NexusEvent<T...>, Callback: (T...) -> ()) -> (NexusConnection.NexusConnection<T...>),
    Fire: (self: NexusEvent<T...>, T...) -> (),
    Disconnect: (self: NexusEvent<T...>) -> (),
} & NexusObject.NexusObject



--[[
Creates an event.
--]]
function NexusEvent:__new(): ()
    NexusObject.__new(self)
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")
    self.CurrentWaits = 0

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments, {__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function NexusEvent:Disconnected<T...>(Connection: NexusConnection.NexusConnection<T...>): ()
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function NexusEvent:Disconnect(): ()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection, _ in self.Connections do
        table.insert(ConnectionsToDisconnect, Connection)
    end
    
    --Disconnect the events.
    for _, Connection in ConnectionsToDisconnect do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function NexusEvent:Connect<T...>(Callback: (T...) -> ()): NexusConnection.NexusConnection<T...>
    --Create the connection.
    local Connection = NexusConnection.new(self, Callback :: any)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[UUID] = nil

        --Fire the event.
        Connection:Fire(table.unpack(Arguments))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Fires the event.
--]]
function NexusEvent:Fire<T>(...: T): ()
    --Ignore if there are no connections.
    --If continued, self.LastArgumentsStrong will be populated and never cleared, leading to a memory leak.
    if next(self.Connections) == nil and self.CurrentWaits <= 0 then return end

    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function NexusEvent:Wait<T>(): (T)
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[UUID] = nil
    return table.unpack(Arguments)
end



return NexusEvent :: NexusEvent<>]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX099043405E2341C89638C8E0B93E242F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NexusInstance</string>
							<string name="ScriptGuid">{925559D6-6CFC-4C48-B7E3-5AA6B369E6AB}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]
--!strict

local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName("NexusInstance")

export type LegacyPropertyValidator = {
    ValidateChange: (self: LegacyPropertyValidator, Object: NexusInstance, Index: string, Value: any) -> (any),
}
export type NexusInstance = {
    new: () -> (NexusInstance),
    Extend: (self: NexusInstance) -> (NexusInstance),

    Changed: NexusEvent.NexusEvent<string>,
    AddGenericPropertyValidator: (self: NexusInstance, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddPropertyValidator: (self: NexusInstance, PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddGenericPropertyFinalizer: (self: NexusInstance, Finalizer: (string, any) -> ()) -> (),
    AddPropertyFinalizer: (self: NexusInstance, PropertyName: string, Finalizer: (string, any) -> ()) -> (),
    LockProperty: (self: NexusInstance, PropertyName: string) -> (),
    HidePropertyChanges: (self: NexusInstance, PropertyName: string) -> (),
    HideNextPropertyChange: (self: NexusInstance, PropertyName: string) -> (),
    GetPropertyChangedSignal: (self: NexusInstance, PropertyName: string) -> (NexusEvent.NexusEvent<>),
    Destroy: (self: NexusInstance) -> (),
} & NexusObject.NexusObject



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new(): ()
    --Set up the base object.
    NexusObject.__new(self)

    --Set up the internal properties.
    self:__InitInternalProperties()
    self:__InitMetaMethods()
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties(): ()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEvent.new()
    self.Changed = self.__ChangedEvent

    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods(): ()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent

    --Set up custom indexing.
    local Metatable = {}
    local OriginalIndexTable = getmetatable(self).__index
    setmetatable(self, Metatable)
    Metatable.__index = function(_, Index: string): any
        --Return the internal property.
        local InternalPropertyValue = InternalProperties[Index]
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end

        --Return the base return.
        return OriginalIndexTable[Index]
    end

    --Set up changes.
    Metatable.__newindex = function(_, Index: string, Value: any): ()
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end

        --Return if the new and old values are the same.
        if self[Index] == Value then
            return
        end

        --Validate the value.
        for _,Validator in GenericPropertyValidators do
            Value = Validator(Index, Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _, Validator in Validators do
                Value = Validator(Index, Value)
            end
        end

        --Change the property.
        InternalProperties[Index] = Value

        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _, Finalizer in GenericPropertyFinalizers do
            Finalizer(Index, Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _, Finalizer in Finalizers do
                Finalizer(Index, Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end

        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end

        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddGenericPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddGenericPropertyValidator(function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    table.insert(self.__GenericPropertyValidators, Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddPropertyValidator(PropertyName, function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName], Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer: (string, any) -> ()): ()
    table.insert(self.__GenericPropertyFinalizers, Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName: string, Finalizer: (string, any) -> ())
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName], Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName: string): ()
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName: string): ()
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName: string): ()
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName: string): NexusEvent.NexusEvent<>
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEvent.new()
    end

    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in self.__PropertyChanged do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance :: NexusInstance]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4F27AB3C8FC24D81AC9118CC80943BFE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NexusObject</string>
							<string name="ScriptGuid">{92EFD4B4-01D7-46BD-A4F8-A8F6ED17C408}</string>
							<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table: any): string
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil

    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    return String
end

--[[
Extends a class.
--]]
local function ExtendClass(SuperClass: {[string]: any}?) : NexusObject
    --Create the class.
    local Class = {}
    Class.super = SuperClass
    Class.__index = Class
    setmetatable(Class :: any, SuperClass)

    --[[
    Creates an object.
    --]]
    function Class.new(...)
        --Create the base object.
        local self = {} :: NexusObject
        self.__index = self
        self.class = Class
        setmetatable(self :: any, Class)

        --Run the constructor.
        self:__new(...)

        --Return the object.
        return self
    end

    --[[
    Constructor run for the class.
    --]]    
    function Class:__new(...)
        if not SuperClass then return end
        (SuperClass :: NexusObject).__new(self, ...)
    end

    --Add the metamethod passthrough.
    if SuperClass then
        for _, MetatableName in METATABLE_METHODS do
            Class[MetatableName] = SuperClass[MetatableName]
        end
    end

    --Call the callback for the class being extended.
    if SuperClass then
        SuperClass:__classextended(Class)
    end

    --Return the created class.
    return (Class :: any) :: NexusObject
end



--Set up the base Nexus Object class.
local NexusObject = ExtendClass() :: NexusObject
NexusObject.ClassName = "NexusObject"

export type NexusObject = {
    --Properties.
    class: {[string]: any},
    super: NexusObject,
    ClassName: string,
    [string]: any,

    --Static methods.
    new: () -> (NexusObject),
    Extend: (self: NexusObject) -> (NexusObject),
    SetClassName: (self: NexusObject, ClassName: string) -> (NexusObject),

    --Methods.
    IsA: (self: NexusObject, ClassName: string) -> (boolean),
}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass: NexusObject): ()
    if not self.super then return end
    self.super:__classextended(OtherClass)
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring(): string
    local MemoryAddress = string.sub(RawToString(self), 8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject: any): boolean
    return rawequal(self, OtherObject)
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName: string): NexusObject
    self.ClassName = ClassName
    return self
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend(): NexusObject
    return (ExtendClass(self) :: any) :: NexusObject
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName: string): boolean
    --If the class name matches the class name, return true.
    local CurrentClass = self
    while CurrentClass do
        if CurrentClass.ClassName == ClassName then
            return true
        end
        CurrentClass = CurrentClass.super
    end

    --Return false (no match).
    return false
end



return NexusObject]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX0B687EFCA15F4831993B6580F9798582">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">PropertyValidator</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF365DB293CE64904B39910FCA6B411C1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TypePropertyValidator</string>
								<string name="ScriptGuid">{06C294BE-2A3D-4E95-AC13-AC3BD4C4F358}</string>
								<ProtectedString name="Source"><![CDATA[--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName("TypePropertyValidator")

export type TypePropertyValidator = {
    CreateTypeValidator: (Type: string) -> ((string, any) -> (any)),
    new: (Type: string) -> (TypePropertyValidator),
    Extend: (self: TypePropertyValidator) -> (TypePropertyValidator),

    ValidateChange: (self: TypePropertyValidator, Object: any, ValueName: string, Value: any) -> (any),
} & NexusObject.NexusObject



--[[
Creates a type validator for a type.
--]]
function TypePropertyValidator.CreateTypeValidator(Type: string): (string, any) -> (any)
    return function(ValueName: string, Value: any): any
        --Determine the type.
        local TypeMatches, ClassMatches = false, false
        local ValueType = typeof(Value)

        --Determine if the type matchs.
        if ValueType == Type then
            TypeMatches = true
        end

        --Determine if the class name matches.
        if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
            ValueType = Value.ClassName
            if Value:IsA(Type) then
                ClassMatches = true
            end
        end

        --Throw an error if the type is invalid.
        if not TypeMatches and not ClassMatches then
            error("Bad value for \""..tostring(ValueName).."\" ("..tostring(Type).." expected, got "..ValueType..")")
        end

        --Return the original value.
        return Value
    end
end

--[[
Creates a type validator.
--]]
function TypePropertyValidator:__new(Type: string): ()
    warn("TypePropertyValidator.new() is deprecated with object-based validators. Use CreateTypeValidator(Type) instead.")
    NexusObject.__new(self)
    self.Validator = TypePropertyValidator.CreateTypeValidator(Type)
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object: any, ValueName: string, Value: any)
    return self.Validator(ValueName, Value)
end



return TypePropertyValidator :: TypePropertyValidator]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>